<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大小顶堆</title>
      <link href="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/"/>
      <url>/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>大顶堆和小顶堆都是堆</p><p>堆是一种满足以下条件的树：</p><p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p><h1 id="堆得用途"><a href="#堆得用途" class="headerlink" title="堆得用途"></a>堆得用途</h1><p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p><p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是</p><p>O(nlog(n))</p><p>，查找最大值或者最小值时间复杂度都是</p><p>O(1)</p><p>，但是，涉及到更新（插入或删除）数据时，时间复杂度为</p><p>O(n)</p><p>，即使是使用复杂度为</p><p>O(log(n))</p><p>的二分法找到要插入或者删除的数据，在移动数据时也需要</p><p>的时间复杂度。</p><p>因此相对于有序数组而言，堆的主要优势在于更新数据效率较高。</p><h1 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h1><p>堆的插入操作，其实就是将数据插入到堆的末尾，然后通过上浮操作，将数据移动到合适的位置。</p><p>堆的插入操作，时间复杂度为</p><p>O(log(n))</p><h1 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h1><p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p><p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为”「堆化」”，堆化的方法分为两种：</p><p>一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。<br>另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，下面是这两种操作的过程。</p><h2 id="自底向上堆化"><a href="#自底向上堆化" class="headerlink" title="自底向上堆化"></a>自底向上堆化</h2><p><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/1.png" alt><br><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/2.png" alt></p><p>从下往上依次上浮知道没有子节点</p><p><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/3.png" alt><br><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/4.png" alt></p><p>把最小的子节点扔到堆顶然后依次下沉</p><p>堆排序的完整过程：</p><p>建堆，排序</p><h2 id="建堆就是将所有的非叶节点自顶向下堆化"><a href="#建堆就是将所有的非叶节点自顶向下堆化" class="headerlink" title="建堆就是将所有的非叶节点自顶向下堆化"></a>建堆就是将所有的非叶节点自顶向下堆化</h2><p>从下往上把所有的非叶节点看做一个石沉大海的过程</p><p><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/5.png" alt><br><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/6.png" alt></p><h2 id="排序就是一直取出堆顶元素"><a href="#排序就是一直取出堆顶元素" class="headerlink" title="排序就是一直取出堆顶元素"></a>排序就是一直取出堆顶元素</h2><p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p><p>现在思考两个问题：</p><p>删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？<br>取出的堆顶元素存在哪，新建一个数组存？<br>先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。</p><p>机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。</p><p>详细过程如下图所示：</p><p>取出第一个元素并堆化：</p><p><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/7.png" alt><br><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/8.png" alt><br><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/9.png" alt><br><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/10.png" alt><br><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/12.png" alt><br><img src="/2023/09/07/%E5%A4%A7%E5%B0%8F%E9%A1%B6%E5%A0%86/11.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>优先队列</title>
      <link href="/2023/09/07/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>/2023/09/07/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。<br>在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest<br>out）的行为特征。</p><h2 id="优先队列使用"><a href="#优先队列使用" class="headerlink" title="优先队列使用"></a>优先队列使用</h2><p>先要包含头文件#include, 他和queue不同的就在于我们可以自定义其中数据的优先级,让优先级高的排在队列前面,优先出队。</p><pre><code>#include &lt;queue&gt;#include &lt;functional&gt; //greater&lt;&gt;// 定义priority_queue&lt;int&gt; pq;</code></pre><p>2.默认优先输出大数据</p><pre><code>priority_queue&lt;Type, Container, Functional&gt;</code></pre><p>其中, Type 为数据类型. Container 为保存数据的容器. Functional 为元素比较的方式.</p><p>若不写后面两个参数.</p><p>容器 默认使用 vector</p><p>比较方式 默认使用 operator &lt; 即优先队列是大顶堆. 队头元素最大<br>大根堆声明方式：<br>大根堆就是把大的元素放在堆顶的堆。优先队列默认实现的就是大根堆，所以大根堆的声明不需要任何花花肠子，直接按C++STL的声明规则声明即可。</p><pre><code>#include&lt;queue&gt;priority_queue&lt;int&gt; q;priority_queue&lt;string&gt; q;priority_queue&lt;pair&lt;int,int&gt; &gt; q;</code></pre><p>C++中的int,string等类型可以直接比较大小</p><p>3.优先输出小数据 即小顶堆</p><pre><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; p;</code></pre><p>使用 greater<int> . 即改用 operator &gt;<br>小根堆声明方式<br>大根堆是把大的元素放堆顶，小根堆就是把小的元素放到堆顶。</int></p><h2 id="实现小根堆有两种方式："><a href="#实现小根堆有两种方式：" class="headerlink" title="实现小根堆有两种方式："></a>实现小根堆有两种方式：</h2><p>第一种是比较巧妙的，因为优先队列默认实现的是大根堆，所以我们可以把元素取反放进去，因为负数的绝对值越小越大，那么绝对值较小的元素就会被放在前面，我们在取出的时候再取个反，就瞒天过海地用大根堆实现了小根堆。</p><p>less&lt;储存的数据类型&gt; 即使用大顶堆<br>greater&lt;储存的数据类型&gt; 即是用小顶堆</p><p>priority_queue&lt;储存的类型,vector&lt;储存的类型&gt;,顶堆的类型&gt; 容器名</p><p>第二种：</p><p>小根堆有自己的声明方式，我们记住即可（我也说不明白道理）：</p><pre><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq2; // 最小堆std::cout &lt;&lt; &quot;start...&quot; &lt;&lt; endl;for (int i = 0; i &lt; 10; i++) &#123;    int t = rand() % 100;    std::cout &lt;&lt; t &lt;&lt; ends;    pq2.push(t);&#125;std::cout &lt;&lt; endl;while (!pq2.empty())&#123;    cout &lt;&lt; pq2.top() &lt;&lt; ends;    pq2.pop();&#125;cout &lt;&lt; endl;</code></pre><h2 id="依靠重载-lt-符号来自定义优先级"><a href="#依靠重载-lt-符号来自定义优先级" class="headerlink" title="依靠重载&lt;符号来自定义优先级"></a>依靠重载&lt;符号来自定义优先级</h2><pre><code>// 定义比较函数// 后面一个表示栈顶元素? 所以这个是 &quot;最小堆&quot;bool myCom(int a, int b) &#123;    return a % 10 &gt; b % 10;&#125;// 使用priority_queue&lt;int, vector&lt;int&gt;, function&lt;bool(int,int)&gt;&gt; pq3(myCom); std::cout &lt;&lt; &quot;start...&quot; &lt;&lt; endl;for (int i = 0; i &lt; 10; i++) &#123;    int t = rand() % 100;    std::cout &lt;&lt; t &lt;&lt; ends;    pq3.push(t);&#125;std::cout &lt;&lt; endl;while (!pq3.empty())&#123;    cout &lt;&lt; pq3.top() &lt;&lt; ends;    pq3.pop();&#125;cout &lt;&lt; endl;</code></pre><h2 id="基本类型优先队列例子"><a href="#基本类型优先队列例子" class="headerlink" title="基本类型优先队列例子"></a>基本类型优先队列例子</h2><pre><code>#include&lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123;//对于基础类型 默认是大顶堆priority_queue&lt;int&gt; a; //等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;//   这里一定要有空格，不然成了右移运算符↓↓priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; c; //这样就是小顶堆priority_queue&lt;string&gt; b;for (int i = 0; i &lt; 5; i++) &#123;    a.push(i);    c.push(i);&#125;while (!a.empty()) &#123;    cout &lt;&lt; a.top() &lt;&lt; &#39; &#39;;    a.pop();&#125; cout &lt;&lt; endl;while (!c.empty()) &#123;    cout &lt;&lt; c.top() &lt;&lt; &#39; &#39;;    c.pop();&#125;cout &lt;&lt; endl;b.push(&quot;abc&quot;);b.push(&quot;abcd&quot;);b.push(&quot;cbd&quot;);while (!b.empty()) &#123;    cout &lt;&lt; b.top() &lt;&lt; &#39; &#39;;    b.pop();&#125; cout &lt;&lt; endl;return 0;&#125;</code></pre><h2 id="自定义类型优先队列例子"><a href="#自定义类型优先队列例子" class="headerlink" title="自定义类型优先队列例子"></a>自定义类型优先队列例子</h2><pre><code>#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;//方法1struct tmp1 //运算符重载&lt;&#123;int x;tmp1(int a) &#123;x = a;&#125;bool operator&lt;(const tmp1&amp; a) const&#123;    return x &lt; a.x; //大顶堆&#125;&#125;;//方法2struct tmp2 //重写仿函数&#123;bool operator() (tmp1 a, tmp1 b) &#123;    return a.x &lt; b.x; //大顶堆&#125;&#125;;int main() &#123;tmp1 a(1);tmp1 b(2);tmp1 c(3);priority_queue&lt;tmp1&gt; d;d.push(b);d.push(c);d.push(a);while (!d.empty()) &#123;    cout &lt;&lt; d.top().x &lt;&lt; &#39;\n&#39;;    d.pop();&#125;cout &lt;&lt; endl;priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;f.push(b);f.push(c);f.push(a);while (!f.empty()) &#123;    cout &lt;&lt; f.top().x &lt;&lt; &#39;\n&#39;;    f.pop();&#125;&#125;</code></pre><h2 id="很多时候，我们不应该重载结构体的运算符。像数据结构vector，它有它的基本运算方法，我们不应该重载它的运算符。此时，我们就应该自定义结构体替代less-lt-gt-和greater-lt-gt-通过重载括号符就可以更改比较规则"><a href="#很多时候，我们不应该重载结构体的运算符。像数据结构vector，它有它的基本运算方法，我们不应该重载它的运算符。此时，我们就应该自定义结构体替代less-lt-gt-和greater-lt-gt-通过重载括号符就可以更改比较规则" class="headerlink" title="很多时候，我们不应该重载结构体的运算符。像数据结构vector，它有它的基本运算方法，我们不应该重载它的运算符。此时，我们就应该自定义结构体替代less&lt;&gt;和greater&lt;&gt;,通过重载括号符就可以更改比较规则"></a>很多时候，我们不应该重载结构体的运算符。像数据结构vector，它有它的基本运算方法，我们不应该重载它的运算符。此时，我们就应该自定义结构体替代less&lt;&gt;和greater&lt;&gt;,通过重载括号符就可以更改比较规则</h2><pre><code>#include&lt;iostream&gt;//c++标准头文件，可以使用cout,cin等标准库函数 #include&lt;queue&gt;//使用priority_queue时需要的头文件 using namespace std;//命名空间，防止重名给程序带来各种隐患，使用cin,cout,stack,map,set,vector,queue时都要使用struct test&#123;//定义一个结构体test     int val;    test(int v)&#123;//构造函数         this-&gt;val=v;    &#125;//    下面是基本的运算方法，我们不能随意更改它     bool operator &gt; (const test t)const&#123;//重载运算符        return val&gt;t.val;    &#125;    bool operator &lt; (const test t)const&#123;//重载运算符        return val&lt;t.val;    &#125;&#125;;struct cmp&#123;    bool operator () (const test t1,const test t2)const&#123;//重载括号运算符        return t1.val&lt;t2.val;//小于号是大根堆，大于号是小根堆     &#125;&#125;;int main()&#123;    priority_queue&lt;test,vector&lt;test&gt;,cmp&gt; q;//自定义一个优先级队列q     cout&lt;&lt;&quot;自定义一个优先级队列q: priority_queue&lt;test,vector&lt;test&gt;,cmp&gt; q&quot;&lt;&lt;endl;     q.push(test(10));//向队列中添加一个test，val的值为10     q.push(test(5));//向队列中添加一个test，val的值为5    q.push(test(7));//向队列中添加一个test，val的值为7    cout&lt;&lt;&quot;q.top().val=&quot;&lt;&lt;q.top().val&lt;&lt;endl;    cout&lt;&lt;endl;     q.pop();    cout&lt;&lt;&quot;q.top().val=&quot;&lt;&lt;q.top().val&lt;&lt;endl;    cout&lt;&lt;endl;     q.pop();    cout&lt;&lt;&quot;q.top().val=&quot;&lt;&lt;q.top().val&lt;&lt;endl;    cout&lt;&lt;endl;     q.pop();    cout&lt;&lt;&quot;目前队列是空的，不能使用q.top()查询队首元素&quot;&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最小割与最大流</title>
      <link href="/2023/09/06/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
      <url>/2023/09/06/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="最小割问题"><a href="#最小割问题" class="headerlink" title="最小割问题"></a>最小割问题</h1><p>最小割问题如图所示<br><img src="/2023/09/06/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/1.png" alt></p><p>割出掉总权重最小的边使a,b不再连通。</p><h1 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h1><p><img src="/2023/09/06/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/2.png" alt><br>找到S,T 中的最大流量</p><h2 id="最小割问腿等价于最大流问题"><a href="#最小割问腿等价于最大流问题" class="headerlink" title="最小割问腿等价于最大流问题"></a>最小割问腿等价于最大流问题</h2><p>因为最大流一定不可能小于最小割。想要流量最大，那么最小割一定被占满，否则就是没有物尽其用。</p><p>最大流也不可能大于最大流，因为最大流所有流量都要经过最小割。</p><h2 id="最大流问题求解"><a href="#最大流问题求解" class="headerlink" title="最大流问题求解"></a>最大流问题求解</h2><p>将图割问题转化为最大流问题并求解即可得到最终的分割结果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>graphcut_grabcut</title>
      <link href="/2023/09/06/graphcut-grabcut/"/>
      <url>/2023/09/06/graphcut-grabcut/</url>
      
        <content type="html"><![CDATA[<h2 id="图割"><a href="#图割" class="headerlink" title="图割"></a>图割</h2><p>背景 <a href="https://blog.csdn.net/wsp_1138886114/article/details/104076134">https://blog.csdn.net/wsp_1138886114/article/details/104076134</a> </p><p>所谓图像分割指的是根据灰度、颜色、纹理和形状等特征把图像划分成若干互不交迭的区域，并使这些特征在同一区域内呈现出相似性，而在不同区域间呈现出明显的差异性。我们先对目前主要的图像分割方法做个概述，后面再对个别方法做详细的了解和学习。</p><p>基于阈值的分割方法</p><p>阈值法的基本思想是基于图像的灰度特征来计算一个或多个灰度阈值，并将图像中每个像素的灰度值与阈值相比较，最后将像素根据比较结果分到合适的类别中。因此，该类方法最为关键的一步就是按照某个准则函数来求解最佳灰度阈值。</p><p>基于边缘的分割方法</p><p>所谓边缘是指图像中两个不同区域的边界线上连续的像素点的集合，是图像局部特征不连续性的反映，体现了灰度、颜色、纹理等图像特性的突变。通常情况下，基于边缘的分割方法指的是基于灰度值的边缘检测，它是建立在边缘灰度值会呈现出阶跃型或屋顶型变化这一观测基础上的方法。</p><p>阶跃型边缘两边像素点的灰度值存在着明显的差异，而屋顶型边缘则位于灰度值上升或下降的转折处。正是基于这一特性，可以使用微分算子进行边缘检测，即使用一阶导数的极值与二阶导数的过零点来确定边缘，具体实现时可以使用图像与模板进行卷积来完成。</p><p>基于区域的分割方法</p><p>此类方法是将图像按照相似性准则分成不同的区域，主要包括种子区域生长法、区域分裂合并法和分水岭法等几种类型。</p><p>种子区域生长法是从一组代表不同生长区域的种子像素开始，接下来将种子像素邻域里符合条件的像素合并到种子像素所代表的生长区域中，并将新添加的像素作为新的种子像素继续合并过程，直到找不到符合条件的新像素为止。该方法的关键是选择合适的初始种子像素以及合理的生长准则。</p><p>区域分裂合并法（Gonzalez，2002）的基本思想是首先将图像任意分成若干互不相交的区域，然后再按照相关准则对这些区域进行分裂或者合并从而完成分割任务，该方法既适用于灰度图像分割也适用于纹理图像分割。</p><p>分水岭法（Meyer，1990）是一种基于拓扑理论的数学形态学的分割方法，其基本思想是把图像看作是测地学上的拓扑地貌，图像中每一点像素的灰度值表示该点的海拔高度，每一个局部极小值及其影响区域称为集水盆，而集水盆的边界则形成分水岭。该算法的实现可以模拟成洪水淹没的过程，图像的最低点首先被淹没，然后水逐渐淹没整个山谷。当水位到达一定高度的时候将会溢出，这时在水溢出的地方修建堤坝，重复这个过程直到整个图像上的点全部被淹没，这时所建立的一系列堤坝就成为分开各个盆地的分水岭。分水岭算法对微弱的边缘有着良好的响应，但图像中的噪声会使分水岭算法产生过分割的现象。</p><p>基于图论的分割方法</p><p>此类方法把图像分割问题与图的最小割（min cut）问题相关联。首先将图像映射为带权无向图G=<V，E>，图中每个节点N∈V对应于图像中的每个像素，每条边∈E连接着一对相邻的像素，边的权值表示了相邻像素之间在灰度、颜色或纹理方面的非负相似度。而对图像的一个分割s就是对图的一个剪切，被分割的每个区域C∈S对应着图中的一个子图。而分割的最优原则就是使划分后的子图在内部保持相似度最大，而子图之间的相似度保持最小。基于图论的分割方法的本质就是移除特定的边，将图划分为若干子图从而实现分割。目前所了解到的基于图论的方法有GraphCut，GrabCut和Random Walk等。</V，E></p><p>基于能量泛函的分割方法</p><p>该类方法主要指的是活动轮廓模型（active contour model）以及在其基础上发展出来的算法，其基本思想是使用连续曲线来表达目标边缘，并定义一个能量泛函使得其自变量包括边缘曲线，因此分割过程就转变为求解能量泛函的最小值的过程，一般可通过求解函数对应的欧拉(Euler．Lagrange)方程来实现，能量达到最小时的曲线位置就是目标的轮廓所在。按照模型中曲线表达形式的不同，活动轮廓模型可以分为两大类：参数活动轮廓模型（parametric active contour model）和几何活动轮廓模型（geometric active contour model）。</p><p>参数活动轮廓模型是基于Lagrange框架，直接以曲线的参数化形式来表达曲线，最具代表性的是由Kasset a1(1987)所提出的Snake模型。该类模型在早期的生物图像分割领域得到了成功的应用，但其存在着分割结果受初始轮廓的设置影响较大以及难以处理曲线拓扑结构变化等缺点，此外其能量泛函只依赖于曲线参数的选择，与物体的几何形状无关，这也限制了其进一步的应用。</p><p>几何活动轮廓模型的曲线运动过程是基于曲线的几何度量参数而非曲线的表达参数，因此可以较好地处理拓扑结构的变化，并可以解决参数活动轮廓模型难以解决的问题。而水平集（Level Set）方法（Osher，1988）的引入，则极大地推动了几何活动轮廓模型的发展，因此几何活动轮廓模型一般也可被称为水平集方法。</p><h2 id="graphcut"><a href="#graphcut" class="headerlink" title="graphcut"></a>graphcut</h2><p>graphcut是一个经典的图论分割方法，使用图的最小割来解决分割问题。</p><h3 id="图的最小割与最大流"><a href="#图的最小割与最大流" class="headerlink" title="图的最小割与最大流"></a>图的最小割与最大流</h3><p>Interactive Graph Cuts for Optimal Boundary &amp; Region Segmentation of Objects in N-D Images 图割算法最早由该论文提出并且设计了Graph Cuts算法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>条件随机场CRF</title>
      <link href="/2023/09/05/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF/"/>
      <url>/2023/09/05/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF/</url>
      
        <content type="html"><![CDATA[<h1 id="条件随机场CRF"><a href="#条件随机场CRF" class="headerlink" title="条件随机场CRF"></a>条件随机场CRF</h1><p>CRF：是马尔科夫随机场的特例，它假设马尔科夫随机场中只有X和Y两种变量，X一般是给定的，而Y一般是在给定X的条件下我们的输出。</p><p>线性链条件随机场：X和Y有相同的结构的CRF就构成了线性链条件随机场。</p><p>CRF的数学语言描述：设X与Y是随机变量，P(Y|X)是给定X时Y的条件概率分布，若随机变量Y构成的是一个马尔可夫随机场，则称条件概率分布P(Y|X)是条件随机场，(判别式模型)。</p><p><img src="/2023/09/05/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF/1.PNG" alt></p><h2 id="线性链条件随机场"><a href="#线性链条件随机场" class="headerlink" title="线性链条件随机场"></a>线性链条件随机场</h2><p><img src="/2023/09/05/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF/1.webp" alt></p><p>y2的得分由一个转移得分f(y2，y1)加上一个特征得分g(y2，x2)构成，其中y1是y2的前一个状态，x2是y2对应的特征。因此整个y的得分为<br>g(y1，x1) + f(y1，b)+g(y2，x2) + f(y2，y1)+…+g(yn，xn) + f(yn，yn-1)组成。由于只有一个组合Y是对的，因此我们希望对的得分越大越好。还可以人为设定一些约束条件。比如y=a后y！=b之类。最终公式如下。<br><img src="/2023/09/05/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF/2.webp" alt><br>我们需要优化的就是这些权值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最大熵模型</title>
      <link href="/2023/09/05/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/09/05/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="最大熵模型"><a href="#最大熵模型" class="headerlink" title="最大熵模型"></a>最大熵模型</h2><h3 id="熵与条件熵"><a href="#熵与条件熵" class="headerlink" title="熵与条件熵"></a>熵与条件熵</h3><p>熵是热力学的概念，香农用它来表示一个随机变量分布的混乱程度<br><img src="/2023/09/05/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/熵.webp" alt><br>条件熵与熵类似，表示的是在某一个条件下，某个随机变量的熵。<br><img src="/2023/09/05/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/条件熵.webp" alt><br>既然熵代表的是混乱程度，那么很容易理解，当随机变量是均匀分布时，我们完全不能猜出随机变量的值，那么它的熵就是最大的。而当随机变量是一个确定的值时，我们完全能猜出随机变量的值，那么它的熵就是最小的。</p><h3 id="最大熵原理"><a href="#最大熵原理" class="headerlink" title="最大熵原理"></a>最大熵原理</h3><p>最大熵原理认为在所有可能的概率模型(分布) 中，熵最大的模型是最好的模型(分布)。</p><h3 id="根据最大熵原理选择最大熵模型"><a href="#根据最大熵原理选择最大熵模型" class="headerlink" title="根据最大熵原理选择最大熵模型"></a>根据最大熵原理选择最大熵模型</h3><p>假设分类模型是一个条件概率分布P(Y|X),X表示输入,Y表示输出。这个模型表示的是对于给定的输入X,以条件概率P(Y|X)输出Y。<br>给定一个训练数据集T,我们的目标就是利用最大熵原理选择最好的分类模型。</p><p>按照最大熵原理,我们应该优先保证模型满足已知的所有约束。那么如何得到这些约束呢?<br>思路是:从训练数据T中抽取若干特征,然后要求这些特征在T上关于经验分布的期望与它们在模型中关于p(x,y)的数学期望相等,这样,一个特征就对应一个约束。</p><p>因此一个完整的最大熵模型如下所示：<br><img src="/2023/09/05/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/条件优化问题.png" alt><br>他是一个有一些约束的约束最优化问题</p><h3 id="拉格朗日乘数法"><a href="#拉格朗日乘数法" class="headerlink" title="拉格朗日乘数法"></a>拉格朗日乘数法</h3><p>拉格朗日乘数法是一种数学方法，用于求解约束优化问题。它通过引入拉格朗日乘数来将约束优化问题变为无约束优化问题，然后使用最优化方法求解。</p><p><img src="/2023/09/05/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/lage.png" alt></p><p><img src="/2023/09/05/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/1.jpg" alt></p><p>两个曲线的梯度向量平行时，两曲线相切<br>在切点处的y条件下，g(x,y)与z（x,y）是相切的</p><p>即</p><p><img src="/2023/09/05/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/1.png" alt></p><p>再加上原本问题g(x,y)=0</p><p><img src="/2023/09/05/%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B/2.png" alt></p><p>刚好是 f(x,y)+lambda<em>g(x,y)=0的最优化问题<br>因此f(x,y)+lambda</em>g(x,y)就叫做拉格朗日函数。</p><p>最后使用拉格朗日乘数法解决上述问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>隐马尔可夫模型</title>
      <link href="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="隐马模型"><a href="#隐马模型" class="headerlink" title="隐马模型"></a>隐马模型</h1><p>隐马模型指的是：随机变量序列不服从马尔可夫模型，而是随机序列的隐藏状态服从马尔可夫模型。</p><p><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/1.png" alt></p><p>其中随机变量s1,s2,s3,s4是一个马尔可夫序列。</p><h2 id="隐马模型可以解决的三个问题："><a href="#隐马模型可以解决的三个问题：" class="headerlink" title="隐马模型可以解决的三个问题："></a>隐马模型可以解决的三个问题：</h2><p>1：评估：给定隐马模型，评估当前序列的出现概率</p><p>2：解码：给定隐马模型及观测序列，求得隐藏状态序列</p><p>3：学习：给定观测序列，学的隐马模型。</p><h2 id="隐马模型的评估"><a href="#隐马模型的评估" class="headerlink" title="隐马模型的评估"></a>隐马模型的评估</h2><h3 id="评估方式1"><a href="#评估方式1" class="headerlink" title="评估方式1"></a>评估方式1</h3><p>枚举所有序列分布。费时</p><h3 id="评估方式2"><a href="#评估方式2" class="headerlink" title="评估方式2"></a>评估方式2</h3><h4 id="前向传播算法"><a href="#前向传播算法" class="headerlink" title="前向传播算法"></a>前向传播算法</h4><p>使用DP算法（动态规划）。马尔可夫模型作为序列模型很符合DP算法。我们使用dp算法计算出在最终时间步T下的状态分布。具体计算如下：</p><p><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/2.png" alt></p><p>当t=1时，计算出状态S的分布并求出观测点n1的概率分布。</p><p><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/3.png" alt></p><p>根据状态根据t=1时的分布，计算t=2时的隐状态St=2。计算n2的概率分布。</p><p>最终直至计算出序列的分布。</p><p>公式表示如下：</p><p><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/4.png" alt></p><p>DP函数为在t时刻下，序列满足n1-nt，并且当前状态为Si的概率</p><p>后向传播算法与前向转播算法思路一致。</p><h2 id="隐马模型的解码"><a href="#隐马模型的解码" class="headerlink" title="隐马模型的解码"></a>隐马模型的解码</h2><p>解码指的是给定模型的观测序列，和隐马模型，推断出最大似然隐状态分布。使用Viterbi 算法求解</p><p><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/5.webp" alt></p><p>画图理解隐马模型的解码问题</p><p><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/6.png" alt></p><p>当观测序列只有一个o1时，要想让o1取得最大值，那应该选择s1= i 使得bi(o1)最大。bi（）指的是在i这个隐状态下的o=o1的概率分布。举一个天气的例子：</p><p>假设初始天气有阴晴两种状态分布为[0.5,0.5],西瓜甜与不甜的概率在阴天条件下为[0.3,0.7]，晴天则为[0.7,0.3],阴晴的移步转移矩阵为[[0.1,0.9][0.3,0.7]]这个转移矩阵指的是阴-&gt;阴的概率0.1，阴-&gt;晴的概率0.9，晴-&gt;阴的概率0.3，晴-&gt;晴的概率0.7。如果观测到的o1是西瓜不甜，那么很有可能S1应该是阴天。</p><p><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/7.png" alt></p><p>但是如果第二天再去观测西瓜的状态，发现西瓜还是不甜的。那么s1-&gt;s2的序列最有可能是两天阴天吗？答案肯定是否定的。因为连续阴天-&gt;阴天的概率只有0.5*0.1！因此隐马模型的解码问题并非是寻找一个序列s1-&gt;s2-&gt;s3-&gt;s4-&gt;…-&gt;sn使o1-&gt;o2….-&gt;on最大，而是使得他们的联合分布p(s1..-&gt;sn,o1-&gt;on)最大。</p><p>按照这个思路，我们假设观测到西瓜的状态为（不甜，不甜，甜，不甜，甜）使用最大似然的方法预测过去五天的天气状况。</p><p>我们计算一个某一个隐状态下，观测序列为（不甜，不甜，甜，不甜，甜）概率。比如（阴，晴，晴，晴，阴）。他们的联合概率为$(0.5<em>0.7)</em>(0.9<em>0.3)</em>(0.7<em>0.7)</em>(0.7<em>0.3)</em>(0.3*0.3)$。按照这个进度我们只需要计算出序列的概率就可以找到最大似然情况：</p><p><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/8.png" alt><br>这里面的s1指晴，s2指阴o1为甜o2为不甜。但是我们发现竟然有这么多情况当隐状态S的种类比较多时。计算的内容实在太多了。因此实际上要将这个问题视为最短路径问题，并使用维特比算法简化枚举的个数。</p><h3 id="维特比算法"><a href="#维特比算法" class="headerlink" title="维特比算法"></a>维特比算法</h3><p>维特比算法旨在求取最短路径。维特比算法认为，如果最短路径经过某个点，那么他一定也经过了一整个起始点到这个点的最短路径。因此从起始点到这个点的非最短路径是完全不可能是最短路径的一部分的，这些路径将作为非重要路径被舍弃。如图所示。</p><p><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/9.png" alt><br><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/10.png" alt></p><p>在第一步，我们可以假设最短路径经过点p1,1。也可以假设经过p1,2。所以三条基础路径都应该作为最短路径保留。在第二步种，首先假设如果最短路径经过p2,1。那么他一定经过起始点-&gt;p2,1的最短路径即s-&gt;p1,2-&gt;p2,1。而其他路径就作为非重要路径舍弃。这就是维特比算法。</p><h3 id="在隐马模型中使用维特比算法"><a href="#在隐马模型中使用维特比算法" class="headerlink" title="在隐马模型中使用维特比算法"></a>在隐马模型中使用维特比算法</h3><p>我们发现我们之前计算的公式$(0.5<em>0.7)</em>(0.9<em>0.3)</em>(0.7<em>0.7)</em>(0.7<em>0.3)</em>(0.3*0.3)$按照括号也是分五步的，括号内的内容为当前状态i到下一状态j的移步转移概率以及下一状态下得到观测值ot的概率bj(ot)。因此我们可以将每一步作为步长并对之前的路径剪枝。首先画出完整的路径图如下<br><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/11.png" alt><br>剪枝之后的路径为<br><img src="/2023/09/01/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/12.png" alt></p><h2 id="隐马的学习"><a href="#隐马的学习" class="headerlink" title="隐马的学习"></a>隐马的学习</h2><p>隐马学习指的是给定一个观测序列，根据最大似然估计求含参模型中的参数值。就是说在上个问题中，我们假设了初始天气有阴晴两种状态分布为[0.5,0.5],西瓜甜与不甜的概率在阴天条件下为[0.3,0.7]，晴天则为[0.7,0.3],阴晴的移步转移矩阵为[[0.1,0.9][0.3,0.7]]这个转移矩阵指的是阴-&gt;阴的概率0.1，阴-&gt;晴的概率0.9，晴-&gt;阴的概率0.3，晴-&gt;晴的概率0.7，这些就是我们构建的隐马模型的参数。但是现在我们不知道矩阵中的数，但是我们已经观测到了这些观测序列（不甜，不甜，甜，不甜，甜），如何使用极大似然的方法，估计出上面的矩阵中的数据。我们可以发现西瓜的甜这一现象可能是来自晴天的分布，也可能是来自阴天的分布。因此可以将来自哪个天气状态作为一个隐变量，然后使用EM算法来求解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EM算法</title>
      <link href="/2023/08/31/EM%E7%AE%97%E6%B3%95/"/>
      <url>/2023/08/31/EM%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h1><h2 id="Jensen不等式"><a href="#Jensen不等式" class="headerlink" title="Jensen不等式"></a>Jensen不等式</h2><p> Jensen不等式关键词（凸函数，上界,累和为1）</p><h3 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h3><p> 凸函数上任意两点的割线位于函数上方：<br> 数学表达为</p><p><img src="/2023/08/31/EM%E7%AE%97%E6%B3%95/1.png" alt="em"></p><p>公式左侧表示任意两点割线上的任意一点的值，右侧表示这一点的函数值。</p><h3 id="Jensen不等式定义"><a href="#Jensen不等式定义" class="headerlink" title="Jensen不等式定义"></a>Jensen不等式定义</h3><p><img src="/2023/08/31/EM%E7%AE%97%E6%B3%95/2.png" alt="em"></p><p>Jensen不等式为凸函数的泛化形式</p><p>证明过程：</p><p>使用数学归纳法证明：当M=1时等号成立，当M=2时Jensen不等式即为凸函数的定义式。</p><p>需要证明当M&gt;2时假设M=m时成立，则M=m+1时成立：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高斯分布的极大似然估计混合高斯模型</title>
      <link href="/2023/08/31/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/"/>
      <url>/2023/08/31/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="高斯分布的极大似然估计-混合高斯模型"><a href="#高斯分布的极大似然估计-混合高斯模型" class="headerlink" title="高斯分布的极大似然估计/混合高斯模型"></a>高斯分布的极大似然估计/混合高斯模型</h1><p>高斯分布的极大似然估计就是估计高斯分布的均值和方差。求出似然函数的极值点（u，zeta）</p><p><img src="/2023/08/31/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/1.png" alt="高斯分布估计"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>频率派与贝叶斯派</title>
      <link href="/2023/08/31/%E9%A2%91%E7%8E%87%E6%B4%BE%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B4%BE/"/>
      <url>/2023/08/31/%E9%A2%91%E7%8E%87%E6%B4%BE%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B4%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="参数估计中的高斯派与频率派"><a href="#参数估计中的高斯派与频率派" class="headerlink" title="参数估计中的高斯派与频率派"></a>参数估计中的高斯派与频率派</h1><p>高斯派：参数是一个分布，求出分布并找出最大概率点<br>频率点：参数是一个常数。</p><h2 id="频率派极大似然估计"><a href="#频率派极大似然估计" class="headerlink" title="频率派极大似然估计"></a>频率派极大似然估计</h2><p>极大似然估计：在参数zeta条件下，p(x|zeta)应该是最大的。</p><p><img src="/2023/08/31/%E9%A2%91%E7%8E%87%E6%B4%BE%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B4%BE/1.png" alt="频率派"></p><p>因此找到上式的极值点即可。</p><p><img src="/2023/08/31/%E9%A2%91%E7%8E%87%E6%B4%BE%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B4%BE/2.png" alt="频率派"></p><h2 id="贝叶斯派最大后验估计"><a href="#贝叶斯派最大后验估计" class="headerlink" title="贝叶斯派最大后验估计"></a>贝叶斯派最大后验估计</h2><p><img src="/2023/08/31/%E9%A2%91%E7%8E%87%E6%B4%BE%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B4%BE/3.png" alt="频率派"></p><p>利用上式计算后验概率</p><p><img src="/2023/08/31/%E9%A2%91%E7%8E%87%E6%B4%BE%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B4%BE/4.png" alt="频率派"></p><p>P(x)为联合概率</p><p><img src="/2023/08/31/%E9%A2%91%E7%8E%87%E6%B4%BE%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B4%BE/5.png" alt="频率派"></p><p>最大后验概率就是要求上面的东西</p><p><img src="/2023/08/31/%E9%A2%91%E7%8E%87%E6%B4%BE%E4%B8%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B4%BE/6.png" alt="频率派"></p><p>分母跟zeta无关</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>circlefitting</title>
      <link href="/2023/08/03/circlefitting/"/>
      <url>/2023/08/03/circlefitting/</url>
      
        <content type="html"><![CDATA[<h1 id="凸轮组筛选"><a href="#凸轮组筛选" class="headerlink" title="凸轮组筛选"></a>凸轮组筛选</h1><p>轴上有两个可视为偏心圆的偏心凸轮，拟合出两个偏心圆的圆心，筛选出异常工件使其偏心角落在180左右。<br>通过将两个偏心圆拟合出来，并记录圆心与相位角。最终得到相位差。</p><p><img src="/2023/08/03/circlefitting/凸轮组.png" alt="凸轮组"></p><h2 id="工件圆拟合"><a href="#工件圆拟合" class="headerlink" title="工件圆拟合"></a>工件圆拟合</h2><p><img src="/2023/08/03/circlefitting/圆拟合.png" alt="拟合圆"></p><p>线性传感器沿基圆转动，并与偏心圆接触。在运动的过程中记录下测量值。同时记录下运动的角度。同时使用最小二乘法拟合圆</p><h2 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h2><p>拟合圆之后，记录下距圆上最远的点，创建一个新点集不包括这些点，重新拟合一次。迭代处理多次最终去除异常点。迭代的过程中只操作初始的点集。不是重复删除</p><h2 id="基圆拟合"><a href="#基圆拟合" class="headerlink" title="基圆拟合"></a>基圆拟合</h2><p>基圆半径是未知的，基圆半径会影响凸轮圆的拟合值。因此需要将基圆拟合出来。已知凸轮半径<br>设置基圆初始值；拟合出凸轮圆，并将其半径与已知半径对比，根据差值缩放基圆半径。迭代处理直至半径与已知值相近。</p><h2 id="c-代码"><a href="#c-代码" class="headerlink" title="c#代码"></a>c#代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace Circle_Fitting</span><br><span class="line">&#123;  /// &lt;summary&gt;</span><br><span class="line">   /// 拟合圆</span><br><span class="line">   /// &lt;/summary&gt;</span><br><span class="line">    public static class CircleFitting</span><br><span class="line">    &#123;</span><br><span class="line">        public struct Circle</span><br><span class="line">        &#123;</span><br><span class="line">            public double X;//圆心X</span><br><span class="line">            public double Y;//圆心Y</span><br><span class="line">            public double R;//半径R</span><br><span class="line">            public double p;//偏心距</span><br><span class="line">            public double zeta;//偏心角</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //private struct point_location</span><br><span class="line">        //&#123;</span><br><span class="line">        //public double point;</span><br><span class="line">        //public int location;</span><br><span class="line"></span><br><span class="line">        //&#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 定义的拟合点</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public const double frequency =473600;</span><br><span class="line">        public const double basecircleR =15000;</span><br><span class="line">        public const int IterationLimit = 200;</span><br><span class="line">        public struct PixelPoint</span><br><span class="line">        &#123;</span><br><span class="line">            public double X;//位移</span><br><span class="line">            public double Y;//分度</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 拟合圆程序</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;pPointList&quot;&gt;要拟合点集&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;返回圆对象&lt;/returns&gt;</span><br><span class="line">        static public Circle FitCircleWithNoBaseCircle(List&lt;PixelPoint&gt; pPointList)</span><br><span class="line">        &#123;</span><br><span class="line">            Circle pCircle = new Circle();</span><br><span class="line">            double X1 = 0;</span><br><span class="line">            double Y1 = 0;</span><br><span class="line">            double X2 = 0;</span><br><span class="line">            double Y2 = 0;</span><br><span class="line">            double X3 = 0;</span><br><span class="line">            double Y3 = 0;</span><br><span class="line">            double X1Y1 = 0;</span><br><span class="line">            double X1Y2 = 0;</span><br><span class="line">            double X2Y1 = 0;</span><br><span class="line">            double p = 0;</span><br><span class="line">            for (int i = 0; i &lt; pPointList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                X1 = X1 + pPointList[i].X;</span><br><span class="line">                Y1 = Y1 + pPointList[i].Y;</span><br><span class="line">                X2 = X2 + pPointList[i].X * pPointList[i].X;</span><br><span class="line">                Y2 = Y2 + pPointList[i].Y * pPointList[i].Y;</span><br><span class="line">                X3 = X3 + pPointList[i].X * pPointList[i].X * pPointList[i].X;</span><br><span class="line">                Y3 = Y3 + pPointList[i].Y * pPointList[i].Y * pPointList[i].Y;</span><br><span class="line">                X1Y1 = X1Y1 + pPointList[i].X * pPointList[i].Y;</span><br><span class="line">                X1Y2 = X1Y2 + pPointList[i].X * pPointList[i].Y * pPointList[i].Y;</span><br><span class="line">                X2Y1 = X2Y1 + pPointList[i].X * pPointList[i].X * pPointList[i].Y;</span><br><span class="line">            &#125;</span><br><span class="line">            double C, D, E, G, H, N;</span><br><span class="line">            double a, b, c;</span><br><span class="line">            N = pPointList.Count;</span><br><span class="line">            C = N * X2 - X1 * X1;</span><br><span class="line">            D = N * X1Y1 - X1 * Y1;</span><br><span class="line">            E = N * X3 + N * X1Y2 - (X2 + Y2) * X1;</span><br><span class="line">            G = N * Y2 - Y1 * Y1;</span><br><span class="line">            H = N * X2Y1 + N * Y3 - (X2 + Y2) * Y1;</span><br><span class="line">            a = (H * D - E * G) / (C * G - D * D);</span><br><span class="line">            b = (H * C - E * D) / (D * D - G * C);</span><br><span class="line">            c = -(a * X1 + b * Y1 + X2 + Y2) / N;</span><br><span class="line">            pCircle.X = a / (-2);</span><br><span class="line">            pCircle.Y = b / (-2);</span><br><span class="line">            pCircle.R = Math.Sqrt(a * a + b * b - 4 * c) / 2;</span><br><span class="line">            p = Math.Sqrt(Math.Pow(a / (-2), 2) + Math.Pow(b / (-2), 2));</span><br><span class="line">            pCircle.p = p;</span><br><span class="line">            pCircle.zeta = ((Math.Acos(pCircle.X / p) / 2) / Math.PI) * 360;</span><br><span class="line">            return pCircle;</span><br><span class="line">        &#125;</span><br><span class="line">        static public Circle FitMultipleCircle(List&lt;PixelPoint&gt; pPointList,int times,double k)</span><br><span class="line">        &#123;</span><br><span class="line">            Circle pCircle = new Circle();</span><br><span class="line">            List&lt;PixelPoint&gt; newPointList = new List&lt;PixelPoint&gt;(pPointList);</span><br><span class="line">            int  point_num = (int)((int)pPointList.Count * k);</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; times; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                //更新pPointList</span><br><span class="line">                pCircle = FitCircleWithNoBaseCircle(newPointList);//</span><br><span class="line">                newPointList = UpdatePixelPoint(pPointList, point_num, pCircle);</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return pCircle;</span><br><span class="line">        &#125;//迭代更新圆</span><br><span class="line">        static public List&lt;PixelPoint&gt; UpdatePixelPoint(List&lt;PixelPoint&gt; pPointList,int k,Circle pcircle)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;PixelPoint&gt; updatePointList = new List&lt;PixelPoint&gt;(pPointList);</span><br><span class="line">            double max_min = 0;</span><br><span class="line">            int max_min_location = 0;</span><br><span class="line">            int[] maxlocation = new int[k];</span><br><span class="line">            double[] max_point = new double[k];</span><br><span class="line">            double distance = 0;</span><br><span class="line">            for (int i = 0; i &lt; pPointList.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                distance = Math.Pow(Math.Pow(pPointList[i].X - pcircle.X, 2) + Math.Pow(pPointList[i].Y - pcircle.Y, 2) - Math.Pow(pcircle.R, 2), 2);</span><br><span class="line">                if (i &lt; k)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlocation[i] = i;</span><br><span class="line">                    max_point[i] = distance;</span><br><span class="line">                    if (i == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        max_min = distance;</span><br><span class="line">                        max_min_location = 0;</span><br><span class="line">                    &#125;//初始化max_min</span><br><span class="line"></span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (max_min &gt; distance)</span><br><span class="line">                        &#123;</span><br><span class="line">                            max_min = distance;</span><br><span class="line">                            max_min_location = i;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    if (max_min &lt; distance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        max_min = distance;</span><br><span class="line">                        maxlocation[max_min_location] = i;</span><br><span class="line">                        max_point[max_min_location] = distance;</span><br><span class="line">                        for (int m = 0; m &lt; k; m++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            if (max_min &gt; max_point[m])</span><br><span class="line">                            &#123;</span><br><span class="line">                                max_min = max_point[m];</span><br><span class="line">                                max_min_location = m;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;//将max[max_min_location],max_location[max_min_location]替换为新节点，重新寻找max_min及location</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Array.Reverse(maxlocation);</span><br><span class="line">            foreach(int m in maxlocation)</span><br><span class="line">            &#123;</span><br><span class="line">                updatePointList.RemoveAt(m);</span><br><span class="line">            &#125;</span><br><span class="line">            //将maxlocation逆序排列并在pPointList中依次删除这些节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            return updatePointList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;//从点集中去除异常点</span><br><span class="line">        static public (Circle,bool)FitCircle(List&lt;double&gt; pPointList1, List&lt;double&gt; pPointList2, double Workpiece_circle_r,double init,double acc,int time,double rate)</span><br><span class="line">        &#123;</span><br><span class="line">            if(pPointList1.Count!= pPointList2.Count|| pPointList1.Count == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                Circle pCircle = new Circle();</span><br><span class="line">                return pCircle;</span><br><span class="line">                Console.WriteLine(&quot;列表长度错误&quot;)；</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125;&quot;, pPointList1.Count)</span><br><span class="line">            if (pPointList1.Count == pPointList2.Count)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;List1,List2长度不匹配&quot;)</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            if (pPointList1.Count == 0|| pPointList2.Count==0)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;list为空&quot;)</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            if (init &lt;= 0 || time &lt;= 1|| rate&lt;=0||rate&gt;=1)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;非法参数&quot;)</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            bool true_1=true;</span><br><span class="line">            Circle pCircle = new Circle();</span><br><span class="line">            double p = init;</span><br><span class="line">            List&lt;PixelPoint&gt; balance = new List&lt;PixelPoint&gt;();</span><br><span class="line">            </span><br><span class="line">            for (int i = 0; i &lt; pPointList1.Count; i = i + 1)</span><br><span class="line">            &#123;</span><br><span class="line">                PixelPoint x1 = new PixelPoint();</span><br><span class="line">                //结构体对象赋值</span><br><span class="line"></span><br><span class="line">                x1.X = (pPointList1[i] + p) * Math.Cos(pPointList2[i] / frequency * 2 * Math.PI);</span><br><span class="line">                x1.Y = (pPointList1[i] + p) * Math.Sin((pPointList2[i] / frequency) * 2 * Math.PI);</span><br><span class="line">                balance.Add(x1);</span><br><span class="line">                Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;, x1.X, x1.Y);</span><br><span class="line">            &#125;</span><br><span class="line">            pCircle = FitMultipleCircle(balance,time,rate);</span><br><span class="line">            double times = 1;</span><br><span class="line">            while (Math.Pow((pCircle.R - Workpiece_circle_r), 2) &gt; Math.Pow(Workpiece_circle_r * acc, 2))</span><br><span class="line">            &#123;</span><br><span class="line">                p = p - (pCircle.R - basecircleR) * ((times / 2 + 1) / times);</span><br><span class="line">                for (int j = 0; j &lt; pPointList1.Count; j = j + 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    PixelPoint x1 = new PixelPoint();</span><br><span class="line">                    //结构体对象赋值</span><br><span class="line"></span><br><span class="line">                    x1.X = (pPointList1[j] + p) * Math.Cos(pPointList2[j] / frequency * 2 * Math.PI);</span><br><span class="line">                    x1.Y = (pPointList1[j] + p) * Math.Sin(pPointList2[j] / frequency * 2 * Math.PI);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    balance[j] = x1;</span><br><span class="line">                    Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;, x1.X, x1.Y);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pCircle = FitMultipleCircle(balance,time,rate);</span><br><span class="line">    </span><br><span class="line">                times = times + 1;</span><br><span class="line">                if (times &gt; IterationLimit)</span><br><span class="line">                &#123;</span><br><span class="line">                    true_1 = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            pCircle = FitMultipleCircle(balance, time, rate);</span><br><span class="line">            Console.WriteLine(&quot;circle.X = &#123;0&#125;, circle.Y = &#123;1&#125;, circle.r = &#123;2&#125;,circle.zate=&#123;3&#125;&quot;, pCircle.X, pCircle.Y, pCircle.R, pCircle.zeta);</span><br><span class="line">            return (pCircle,true_1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>删除注释</title>
      <link href="/2023/08/03/%E5%88%A0%E9%99%A4%E6%B3%A8%E9%87%8A/"/>
      <url>/2023/08/03/%E5%88%A0%E9%99%A4%E6%B3%A8%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="删除代码中的注释"><a href="#删除代码中的注释" class="headerlink" title="删除代码中的注释"></a>删除代码中的注释</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>使用C++中的正则表达式需要引用头文件<regex>。C++标准库中提供了std::regex类来支持正则表达式的操作。</regex></p><p>正则表达式匹配邮箱地址示例</p><p>std::regex pattern(R”(\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*)”);</p><p>其中，R”()”表示将字符串标记为“Raw String”，使得字符串内的特殊字符能够直接被解释而不需要转义。正则表达式中常用的一些特殊字符有：.表示任意一个字符；^<br>表示匹配开头；$表示匹配结尾；*表示匹配0到多个字符；+表示匹配1到多个字符；{n}表示匹配n个字符；{n, m}表示匹配n到m个字符。</p><p>然后，我们可以使用std::regex_match()函数来匹配一个字符串是否符合给定的正则式<br>std::regex_match()会返回一个布尔值。表示是否匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; regex_match(&quot;123&quot;, regex(&quot;\d+&quot;)) &lt;&lt; endl;    //结果为0，需要转义字符&#x27;\&#x27;</span><br><span class="line">cout &lt;&lt; regex_match(&quot;123&quot;, regex(&quot;\\d+&quot;)) &lt;&lt; endl;    //结果为1，完全匹配</span><br></pre></td></tr></table></figure><p>std::regex类提供了很多函数来支持正则表达式的匹配操作。下面是一些常用的函数:</p><p>std::regex_search(str, pattern)：查找给定字符串中第一个满足正则表达式要求的子串。</p><p>std::regex_replace(str, pattern, replacement)：将给定的字符串中匹配正则式的子字符串替换为指定字符串。</p><p>std::sregex_iterator it(str.begin(), str.end(), pattern)：遍历给定字符串中所有匹配正则式的子串。</p><p>std::regex构造函数中可以添加一个参数，用来指定标志。</p><p>std::regex_constants::icase：不区分大小写匹配。<br>std::regex_constants::ECMAScript：使用ECMAScript引擎，支持UTF-8编码。<br>std::regex_constants::extended：使用扩展正则表达式语法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string str(&quot;Hello, World!&quot;);</span><br><span class="line">std::regex pattern(R&quot;(world)&quot;, std::regex_constants::icase);</span><br><span class="line">if (std::regex_search(str, pattern)) &#123;  // true</span><br><span class="line">    std::cout &lt;&lt; &quot;Matched!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第 i 行源码。 这表示每行源码由 ‘\n’ 分隔。</p><p>在 C++ 中有两种注释风格，行内注释和块注释。</p><p>字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。<br>字符串/<em> 表示一个块注释，它表示直到下一个（非重叠）出现的</em>/之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串/*/并没有结束块注释，因为注释的结尾与开头相重叠。<br>第一个有效注释优先于其他注释。</p><p>如果字符串//出现在块注释中会被忽略。<br>同样，如果字符串/*出现在行或块注释中也会被忽略。<br>如果一行在删除注释之后变为空字符串，那么不要输出该行。即，答案列表中的每个字符串都是非空的。</p><p>样例中没有控制字符，单引号或双引号字符。</p><p>比如，source = “string s = “/<em> Not a comment. </em>/“;” 不会出现在测试样例里。<br>此外，没有其他内容（如定义或宏）会干扰注释。</p><p>我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的/*总是开始新的注释。</p><p>最后，隐式换行符可以通过块注释删除。 有关详细信息，请参阅下面的示例。</p><p>从源代码中删除注释后，需要以相同的格式返回源代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; removeComments(vector&lt;string&gt;&amp; source) &#123;</span><br><span class="line">      string str;</span><br><span class="line">        int n=source.size();</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str+=source[i];</span><br><span class="line">            str+=&#x27;\n&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">       string s=regex_replace(str,regex(&quot;//.*|/\\*(.|\n)*?\\*/&quot;),&quot;&quot;);</span><br><span class="line">       vector&lt;string&gt;ans;</span><br><span class="line">        string t;</span><br><span class="line">        for(int i=0;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]==&#x27;\n&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                if(t!=&quot;&quot;)ans.push_back(t);</span><br><span class="line">                t=&quot;&quot;;</span><br><span class="line">            &#125;   </span><br><span class="line">            else t+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>“//.<em>|/\</em>(.|\n)<em>?\</em>/“即为对应的正则表达式：</p><p>//表示//<br>.表示注释里面的任意字符<em>表示匹配任意数量的.字符|表示逻辑或/表示注释中的/，\</em>表示转义后的raw <em>。()表示设定分组。(.|\n)表示<br>任意的字符串或者换行符加上？是因为</em>表示1个或多个，但是也可能存在零个？表示零个或一个。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性扫描</title>
      <link href="/2023/08/03/%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F/"/>
      <url>/2023/08/03/%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="线性扫描解决数组中最大乘积😄"><a href="#线性扫描解决数组中最大乘积😄" class="headerlink" title="线性扫描解决数组中最大乘积😄"></a>线性扫描解决数组中最大乘积😄</h1><h2 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h2><p>遍历数组更新需要的值</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个数组，求数组中任意三个数的乘积的最大值，乘积不会越界</p><p>两个最小的负数和一个最大的正数。三个最大的正数</p><p>排序</p><figure class="highlight plaintext"><figcaption><span>Solution &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>扫描<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int min1 = nums[0];</span><br><span class="line">        int min2;</span><br><span class="line">        int max1= nums[0];</span><br><span class="line">        int max2;</span><br><span class="line">        int max3;</span><br><span class="line">        int a ;</span><br><span class="line">        int b ;</span><br><span class="line">        if (nums[1]&gt;nums[0])&#123;</span><br><span class="line">            min2 = nums[1];</span><br><span class="line">            max2= nums[0];</span><br><span class="line">            max1 = nums[1];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            max2 = nums[1];</span><br><span class="line">            min1 = nums[1];</span><br><span class="line">            min2 = nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[2]&gt;max1)&#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 =max1;</span><br><span class="line">            max1 = nums[2];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(nums[2]&gt;max2)&#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2  = nums[2];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            max3 = nums[2];</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[2]&lt;min1)&#123;</span><br><span class="line">            min2 = min1;</span><br><span class="line">            min1 = nums[2];</span><br><span class="line">        &#125;</span><br><span class="line">        else if (nums[2]&lt;min2)&#123;</span><br><span class="line">            min2 = nums[2];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=3;i&lt;nums.size();i++)&#123;</span><br><span class="line">            if(nums[i]&lt;min1)&#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i]&lt;min2)&#123;</span><br><span class="line">                min2 = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i]&gt;max1)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i]&gt;max2)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 =  nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i]&gt;max3)&#123;</span><br><span class="line">                max3 = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a = min1*min2*max1;</span><br><span class="line">        b  = max1*max2*max3;</span><br><span class="line">        cout &lt;&lt;max1&lt;&lt;max2&lt;&lt;max3&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt;min1&lt;&lt;min2&lt;&lt;endl;</span><br><span class="line">        if(a&gt;b)&#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>写的非常长，初始化max123和min123的时候写了很乱的代码。</p><p>官方题解代码</p><figure class="highlight plaintext"><figcaption><span>Solution &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 最小的和第二小的</span><br><span class="line">        int min1 = INT_MAX, min2 = INT_MAX;</span><br><span class="line">        // 最大的、第二大的和第三大的</span><br><span class="line">        int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;</span><br><span class="line"></span><br><span class="line">        for (int x: nums) &#123;</span><br><span class="line">            if (x &lt; min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = x;</span><br><span class="line">            &#125; else if (x &lt; min2) &#123;</span><br><span class="line">                min2 = x;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (x &gt; max1) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = x;</span><br><span class="line">            &#125; else if (x &gt; max2) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = x;</span><br><span class="line">            &#125; else if (x &gt; max3) &#123;</span><br><span class="line">                max3 = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max(min1 * min2 * max1, max1 * max2 * max3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化max为INT_MIN//int的最小值 min为最大值。不需要手动初始化三个最大值与两个最小值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2023/08/03/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/08/03/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="leecode-c-simplest-diary"><a href="#leecode-c-simplest-diary" class="headerlink" title="leecode c++ simplest diary"></a>leecode c++ simplest diary</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h3 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; r(0,0);</span><br><span class="line">        for (int i = 0;i&lt;nums.size()-2;++i)&#123;</span><br><span class="line">            for (int j = i + 1 ;j&lt;nums.size()-1;++j)&#123;</span><br><span class="line">                if (i + j == target)&#123;</span><br><span class="line">                    r[0]=i;</span><br><span class="line">                    r[1]=j;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用hashtable"><a href="#使用hashtable" class="headerlink" title="使用hashtable"></a>使用hashtable</h3><p>c++ hashtable 由 unordered_maps 实现，分别使用 insert在哈希表中插入元素<br>使用find 方法查找哈希表对应元素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        std::unordered_map&lt;int,int&gt; nums_map;//unordered_map实现哈希表</span><br><span class="line">        for(int i=0;i&lt;nums.size();++i)&#123;</span><br><span class="line">            auto it = nums_map.find(target-nums[i]);//it为结构体指针</span><br><span class="line">            if(it != nums_map.end())&#123;</span><br><span class="line">                return &#123;it-&gt;second, i&#125;;//first指向 key，second指向value</span><br><span class="line">            &#125;</span><br><span class="line">            nums_map[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>两数相加</title>
      <link href="/2023/08/03/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2023/08/03/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="链表两数之和"><a href="#链表两数之和" class="headerlink" title="链表两数之和"></a>链表两数之和</h1><p><img src="/2023/08/03/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/两数相加.png" alt="两数相加"></p><p>head为输出结果头节点</p><p>now维当前操作节点</p><p>最后如果需要进位则判断进位是否为零不为零则new一个节点作为首位<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *head = nullptr ;</span><br><span class="line">        ListNode *now = nullptr;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        while(l1||l2)&#123;</span><br><span class="line">            int n1 = l1? l1 -&gt; val :0;</span><br><span class="line">            int n2 = l2? l2 -&gt; val :0;</span><br><span class="line">            int sum = n1+n2+carry;</span><br><span class="line">            if (!head)&#123;</span><br><span class="line">                head = new ListNode(sum%10);</span><br><span class="line">                now =head;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                now -&gt;next = new ListNode(sum%10);</span><br><span class="line">                now = now -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry =sum/10;</span><br><span class="line">            if(l1)&#123;</span><br><span class="line">                l1 = l1 -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2)&#123;</span><br><span class="line">                l2 = l2 -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (carry&gt;0)&#123;</span><br><span class="line">            now -&gt;next =new ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2023/08/03/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2023/08/03/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="递归线性问题的快速幂计算"><a href="#递归线性问题的快速幂计算" class="headerlink" title="递归线性问题的快速幂计算"></a>递归线性问题的快速幂计算</h1><h2 id="示例：斐波那契数列"><a href="#示例：斐波那契数列" class="headerlink" title="示例：斐波那契数列"></a>示例：斐波那契数列</h2><p>f(x)=f(x-1)+f(x-2);f(0)=1;f(1)=2;</p><h3 id="递归计算斐波那契数列"><a href="#递归计算斐波那契数列" class="headerlink" title="递归计算斐波那契数列"></a>递归计算斐波那契数列</h3><p>矩阵形式如下</p><p><img src="/2023/08/03/%E5%BF%AB%E9%80%9F%E5%B9%82/快速幂.png" alt="快速幂"></p><p>因此</p><p><img src="/2023/08/03/%E5%BF%AB%E9%80%9F%E5%B9%82/快速幂1.png" alt="快速幂1"></p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂计算原理<br>暂存幂运算的中间值；<br>示例计算2的15次方</p><p><img src="/2023/08/03/%E5%BF%AB%E9%80%9F%E5%B9%82/快速幂2.png" alt="快速幂1"></p><p>为什么会快<br>传统计算过程为连乘15-1次</p><p>快速幂计算流程：1，保存2的一次方</p><p>2.将2的一次方乘2的一次方得到2的二次方，并与之前的计算结果相乘</p><p>3.同理计算次数为2+2+2 = 6次</p><p>矩阵快速幂同理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>滑窗不重复子串</title>
      <link href="/2023/08/03/%E6%BB%91%E7%AA%97%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/08/03/%E6%BB%91%E7%AA%97%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/2023/08/03/%E6%BB%91%E7%AA%97%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/最长不重复子串.png" alt="图示"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int a=0;</span><br><span class="line">        int b=0;</span><br><span class="line">        int len = 1;</span><br><span class="line">        if (s.size()==0)&#123;//s为零时；</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        while(b&lt;s.size()-1)&#123;</span><br><span class="line">            b = b+1;</span><br><span class="line">            for (int i=a;i&lt;b;i++)&#123;</span><br><span class="line">                if (s[i]==s[b])&#123;</span><br><span class="line">                    a = i+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (b-a+1&gt;len)&#123;</span><br><span class="line">            len = b-a+1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2023/08/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/08/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>基础题反转链表</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight plaintext"><figcaption><span>Solution &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode *pre = nullptr;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        while (curr)&#123;</span><br><span class="line">            ListNode* next = curr -&gt;next;</span><br><span class="line">            curr -&gt;next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路，反转链表就是将每一个listnode的next变为这个node的pre；所以我们需要记下pre，记下当前node并令node-&gt;next=pre；此外由于链表的下一节点地址会<br>因此丢失，因此我们需要提前保留下next节点的地址</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(!head||!head -&gt;next)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newhead = reverseList(head-&gt;next);</span><br><span class="line">        head -&gt;next -&gt;next = head;</span><br><span class="line">        head -&gt;next = nullptr;</span><br><span class="line">        return newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最长有效括号</title>
      <link href="/2023/08/03/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>/2023/08/03/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h1><h2 id="边界条件与转移矩阵"><a href="#边界条件与转移矩阵" class="headerlink" title="边界条件与转移矩阵"></a>边界条件与转移矩阵</h2><p><img src="/2023/08/03/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/有效括号.png" alt="有效括号"><br>边界条件：寻找最短有效括号（）dp[i][j=i+1]意为是否为最短有效括号</p><p>转移方式：当dp[i][j]为有效括号，且dp[j+1][j+2]为有效括号则dp[i][j+2]为有效括号</p><p>当dp[i][j]为有效括号，且s[i-1]与s[j+1]为有效括号，则dp[i-1][j+1]为有效括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestValidParentheses(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        int maxlen = 0;</span><br><span class="line">        int begin = 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp (n,vector&lt;int&gt;(n));</span><br><span class="line">        if (n&lt;2)&#123;</span><br><span class="line">            return maxlen;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0;i&lt;n-1;i++)&#123;</span><br><span class="line">            if (s[i]==&#x27;(&#x27;&amp;&amp; s[i+1]==&#x27;)&#x27;)&#123;</span><br><span class="line">                dp[i][i+1] = true;</span><br><span class="line">                maxlen = 2;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                dp[i][i+1]=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j=4;j&lt;=n;j=j+2)&#123;</span><br><span class="line">            for (int k = 0;k&lt;n;k++)&#123;</span><br><span class="line">                int m = k+j-1;</span><br><span class="line">                if (m&gt;=n)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (s[k]==&#x27;(&#x27;&amp;&amp;s[m]==&#x27;)&#x27;&amp;&amp;dp[k+1][m-1])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[k][m]=true;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int z = k;z&lt;m;z++)&#123;</span><br><span class="line">                    if(dp[k][z]==true&amp;&amp;dp[z+1][m]==true)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[k][m]=true;</span><br><span class="line">                                       &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if ( dp[k][m]==true)&#123;</span><br><span class="line">                    if((m-k+1)&gt;maxlen)&#123;</span><br><span class="line">                        maxlen = m-k+1;</span><br><span class="line">                        begin = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果超时了。。。。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>动态规划官方题解只建立了一个一维的转移矩阵原因就是知道连续的括号的结尾的话，是可以直接算出来开头的，所以建立二维的向量很浪费。</p><p>括号可以用栈很简单的做出来</p><p>利用括号的性质，设置left和right计数器。从左至右遍历right大于left则为无效括号将计数器归零。当right等于left时记下最长长度。但是这样做当右括号多于左括号时无结果，因此还要从右至左反方向遍历一遍，此时判断条件与之前相反，取两次遍历的最大值作为输出结果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dp回文子串</title>
      <link href="/2023/08/03/dp%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/08/03/dp%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="leecode-c-dp-diary"><a href="#leecode-c-dp-diary" class="headerlink" title="leecode c++ dp diary"></a>leecode c++ dp diary</h1><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><img src="/2023/08/03/dp%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/huiwen.png" alt="图片"></p><p>状态转移图示;转移步骤分三步：<br>1.m[i][i]=1;<br>2.判断m[i][i+1]是否为回文子串；<br>3.沿箭头方向判断是否为回文字串；<br>状态转移类似于记忆化搜索，需要保留中间结果以减少计算时间，因此需要沿箭头方向遍历。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        int maxlen = 1;//记录最大长度</span><br><span class="line">        int begin=0;//记录起始位置</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n&lt;2)&#123;//字符串长度为1时本身为最大字串</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; p(n, vector&lt;int&gt;(n));定义转移矩阵</span><br><span class="line">        for (int i = 0 ;i&lt;n;i++)&#123;//边界条件1</span><br><span class="line">            p[i][i]= true;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int q = 0 ;q&lt;n-1;q++)&#123;//边界条件2</span><br><span class="line">            if (s[q]==s[q+1])&#123;</span><br><span class="line">                p[q][q+1]= true;</span><br><span class="line">                maxlen = 2;//更新最大长度</span><br><span class="line">                begin = q;//更新初始位置</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                p[q][q+1]= false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int l = 3;l&lt;=n;l++)&#123;//从长度为3开始遍历</span><br><span class="line">            for(int left = 0;left&lt;n;left++)&#123;//左边界0-n</span><br><span class="line">                int right = left+l-1;//计算右边界</span><br><span class="line">                if (right&gt;=n)&#123;//判断是否出界</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (s[left]!=s[right])&#123;//左右不相等则为flase</span><br><span class="line">                    p[left][right]=false;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;//左右相等则查询箭头反方向是否为回文字串</span><br><span class="line">                    p[left][right] = p[left+1][right-1];</span><br><span class="line">                &#125;</span><br><span class="line">                if (p[left][right] &amp;&amp; right - left + 1 &gt; maxlen) &#123;//更新maxlen和begin</span><br><span class="line">                    maxlen = right - left + 1;</span><br><span class="line">                    begin = left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substr(begin,maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>R-CNN FastRCNN FasterRCNN</title>
      <link href="/2022/09/14/R-CNN-FastRCNN-FasterRCNN/"/>
      <url>/2022/09/14/R-CNN-FastRCNN-FasterRCNN/</url>
      
        <content type="html"><![CDATA[<h2 id="IOU-Intersection-over-Union"><a href="#IOU-Intersection-over-Union" class="headerlink" title="IOU(Intersection over Union)"></a>IOU(Intersection over Union)</h2><p> IoU是一种测量在特定数据集中检测相应物体准确度的一个标准。IoU是一个简单的测量标准，只要是在输出中得出一个预测范围(bounding boxex)的任务都可以用IoU来进行测量。为了可以使IoU用于测量任意大小形状的物体检测，我们需要：</p><p>ground-truth bounding boxes（人为在训练集图像中标出要检测物体的大概范围）<br>我们的算法得出的结果范围。<br>       也就是说，这个标准用于测量真实和预测之间的相关度，相关度越高，该值越高。如下图所示。绿色标线是人为标记的正确结果（ground-truth），红色标线是算法预测的结果（predicted）。</p><h2 id="RCNN"><a href="#RCNN" class="headerlink" title="RCNN"></a>RCNN</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>RCNN算法分为4个步骤</p><p>一张图像生成1K~2K个候选区域<br>对每个候选区域，使用深度网络提取特征<br>特征送入每一类的SVM 分类器，判别是否属于该类<br>使用回归器精细修正候选框位置</p><h3 id="候选区域生成"><a href="#候选区域生成" class="headerlink" title="候选区域生成"></a>候选区域生成</h3><p>使用了Selective Search1方法从一张图像生成约2000-3000个候选区域。基本思路如下：</p><p>使用一种过分割手段，将图像分割成小区域<br>查看现有小区域，合并可能性最高的两个区域。重复直到整张图像合并成一个区域位置<br>输出所有曾经存在过的区域，所谓候选区域<br>候选区域生成和后续步骤相对独立，实际可以使用任意算法进行。</p><h4 id="候选区域合并"><a href="#候选区域合并" class="headerlink" title="候选区域合并"></a>候选区域合并</h4><p>优先合并以下四种区域：</p><p>颜色（颜色直方图）相近的<br>纹理（梯度直方图）相近的<br>合并后总面积小的<br>合并后，总面积在其BBOX中所占比例大的<br>第三条，保证合并操作的尺度较为均匀，避免一个大区域陆续“吃掉”其他小区域。</p><h4 id="多样化与后处理"><a href="#多样化与后处理" class="headerlink" title="多样化与后处理"></a>多样化与后处理</h4><p>为尽可能不遗漏候选区域，上述操作在多个颜色空间中同时进行（RGB,HSV,Lab等）。在一个颜色空间中，使用上述四条规则的不同组合进行合并。所有颜色空间与所有规则的全部结果，在去除重复后，都作为候选区域输出。</p><h2 id="FastRCNN"><a href="#FastRCNN" class="headerlink" title="FastRCNN"></a>FastRCNN</h2><p>将候选区域生成这一步放到特征图之后，这样可以不对所有的候选区域都单独做一次前向传播</p><h2 id="FasterRCNN"><a href="#FasterRCNN" class="headerlink" title="FasterRCNN"></a>FasterRCNN</h2><p>核心思想是使用CNN卷积神经网络直接产生Region Proposal，使用的方法本质上就是滑动窗口（只需在最后的卷积层上滑动一遍），因为anchor机制和边框回归可以得到多尺度多长宽比的Region Proposal。</p><p>RPN网络也是全卷积网络（FCN，fully-convolutional network），可以针对生成检测建议框的任务端到端地训练，能够同时预测出object的边界和分数。只是在CNN上额外增加了2个卷积层（全卷积层cls和reg）。</p><p>①将每个特征图的位置编码成一个特征向量（256dfor ZF and 512d for VGG）。</p><p>②对每一个位置输出一个objectness score和regressedbounds for k个region proposal，即在每个卷积映射位置输出这个位置上多种尺度（3种）和长宽比（3种）的k个（3*3=9）区域建议的物体得分和回归边界。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>efficientnet</title>
      <link href="/2022/09/14/efficientnet/"/>
      <url>/2022/09/14/efficientnet/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对网络的扩展一般分为增加深度与增加宽度，efficientnet通过实验从depth, width, resolution 这三个维度去缩放模型。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shufflenet</title>
      <link href="/2022/09/14/Shufflenet/"/>
      <url>/2022/09/14/Shufflenet/</url>
      
        <content type="html"><![CDATA[<p>论文：ShuffleNet: An Extremely Efficient Convolutional Neural Network for Mobile Devices<br>论文链接：<a href="https://arxiv.org/abs/1707.01083">https://arxiv.org/abs/1707.01083</a></p><h2 id="算法详解："><a href="#算法详解：" class="headerlink" title="算法详解："></a>算法详解：</h2><p>ShuffleNet是一篇用于降低网络参数量的论文。ShuffleNet使用分组卷积的操作方式降低网络参数。分组卷积最早在Alexnet中使用。后续依次被resnet和<br>MobileNet借鉴。MobileNet使用了深度可分离卷积的方法减少了网络参数。具体方法是使用w<em>h</em>1的depthwise卷积和1<em>1</em>C的pointwise卷积。<br>其中depthwise卷积可以看作是分组数等于通道数的分组卷积。通过分组的方式减少网络的参数量。ShuffleNet在MobileNet的基础上。对point wise卷积也采用了分组卷积的方式<br>来减少point wise卷积的参数量。但是这样做会产生边界效应。即在最终的输出结果中有某些通道没有被计算。为了解决这个问题ShuffleNet使用了channel shuffle<br>的操作。如图所示使用通道重排的方式使得输出的特征图使用所有的通道来计算。<br><img src="/2022/09/14/Shufflenet/1.jpg" alt></p><h2 id="特征提取和下采样"><a href="#特征提取和下采样" class="headerlink" title="特征提取和下采样"></a>特征提取和下采样</h2><p><img src="/2022/09/14/Shufflenet/2.jpg" alt><br>Figure2（b）中的第一个1<em>1卷积是GConv，表示group convolution。Figure2（a）是ResNet中的bottleneck unit，不过将原来的3</em>3 Conv改成3<em>3 DWConv，作者的ShuffleNet主要也是在这基础上做改动。首先用带group的1</em>1卷积代替原来的1<em>1卷积，同时跟一个channel shuffle操作，这个前面也介绍过了。然后是3</em>3 DWConv表示depthwise separable convolution。depthwise separable convolution可以参考MobileNet，下面贴出depthwise separable convolution的示意图。Figure2（c）添加了一个Average pooling和设置了stride=2，另外原来Resnet最后是一个Add操作，也就是元素值相加，而在（c）中是采用concat的操作，也就是按channel合并，类似googleNet的Inception操作。</p><h2 id="与MobileNet相比的改进："><a href="#与MobileNet相比的改进：" class="headerlink" title="与MobileNet相比的改进："></a>与MobileNet相比的改进：</h2><p>作者认为mobilenet中的1*1的point wise卷积还是可以降低参数的，但是使用分组的方式降低参数会导致只有一部分通道参与计算，因此作者使用通道重排的方式改进这个缺点。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>densenet</title>
      <link href="/2022/08/25/densenet/"/>
      <url>/2022/08/25/densenet/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-25 09:19:53</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在深度学习网络中，随着网络深度的加深，梯度消失问题会愈加明显，目前很多论文都针对这个问题提出了解决方案，比如ResNet，Highway Networks，Stochastic depth，FractalNets等，尽管这些算法的网络结构有差别，但是核心都在于：create short paths from early layers to later layers。那么作者是怎么做呢？延续这个思路，那就是在保证网络中层与层之间最大程度的信息传输的前提下，直接将所有层连接起来！<br>dense block的结构图如下。在传统的卷积神经网络中，如果你有L层，那么就会有L个连接，但是在DenseNet中，会有L(L+1)/2个连接。简单讲，就是每一层的输入来自前面所有层的输出。<br><img src="/2022/08/25/densenet/1.jpg" alt></p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p>DenseNet的结构图，在这个结构图中包含了3个dense block。作者将DenseNet分成多个dense block，原因是希望各个dense block内的feature map的size统一，这样在做concatenation就不会有size的问题。<br><img src="/2022/08/25/densenet/2.jpg" alt><br>DenseNet和ResNet的一个明显区别是，ResNet是求和，而DenseNet是做一个拼接，每一层网络的输入包括前面所有层网络的输出。<br>整个网络的结构图。这个表中的k=32，k=48中的k是growth rate，表示每个dense block中每层输出的feature map个数。为了避免网络变得很宽，作者都是采用较小的k，比如32这样，作者的实验也表明小的k可以有更好的效果。根据dense block的设计，后面几层可以得到前面所有层的输入，因此concat后的输入channel还是比较大的。另外这里每个dense block的3<em>3卷积前面都包含了一个1</em>1的卷积操作，就是所谓的bottleneck layer，目的是减少输入的feature map数量，既能降维减少计算量，又能融合各个通道的特征，何乐而不为。另外作者为了进一步压缩参数，在每两个dense block之间又增加了1<em>1的卷积操作。因此在后面的实验对比中，如果你看到DenseNet-C这个网络，表示增加了这个Translation layer，该层的1</em>1卷积的输出channel默认是输入channel到一半。如果你看到DenseNet-BC这个网络，表示既有bottleneck layer，又有Translation layer。<br><img src="/2022/08/25/densenet/3.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DenseNet核心思想在于建立了不同层之间的连接关系，充分利用了feature，进一步减轻了梯度消失问题，加深网络不是问题，而且训练效果非常好。另外，利用bottleneck layer，Translation layer以及较小的growth rate使得网络变窄，参数减少，有效抑制了过拟合，同时计算量也减少了。DenseNet优点很多，而且在和ResNet的对比中优势还是非常明显的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>resnet</title>
      <link href="/2022/08/25/resnet/"/>
      <url>/2022/08/25/resnet/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-25 09:19:40</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>在卷积神经网络中，增加网络深度意味着增加网络的性能，但是这个性能不是无限增加的。当网络增加到一定深度后继续增加网络深度网络的性能可能会随之下降。这是由于神经网络传播过程中信息的丢失和损耗造成的。<br>同时还会有梯度消失或者梯度爆炸的现象。</p><h2 id="概括："><a href="#概括：" class="headerlink" title="概括："></a>概括：</h2><p>resnet解决信息损耗的方法是shortcut或者skip connections。如图所示<img src="/2022/08/25/resnet/2.png" alt>。为了解决这个问题。假设现有一个比较浅的网络（Shallow Net）已达到了饱和的准确率，这时在它后面再加上几个恒等映射层（Identity mapping，也即y=x，输出等于输入），这样就增加了网络的深度，并且起码误差不会增加，也即更深的网络不应该带来训练集上误差的上升。而这里提到的使用恒等映射直接将前一层输出传到后面的思想，便是著名深度残差网络ResNet的灵感来源。</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="/2022/08/25/resnet/1.png" alt><br><img src="/2022/08/25/resnet/4.png" alt><br>如图所示维resnetv1的网络结构。网络前几层使用3<em>3卷积之后接maxpooling提取显著特征同时增大感受野。网络分成4个stage并通过skip connections直接将输入信息绕道传到输出，保护信息的完整性，整个网络只需要学习输入、输出差别的那一部分，简化学习目标和难度。<br><img src="/2022/08/25/resnet/3.png" alt><br>resnet有两种残差连接方式，一种是以两个3</em>3的卷积网络串接在一起作为一个残差模块，另外一种是1<em>1、3</em>3、1*1的3个卷积网络串接在一起作为一个残差模块。他们如图所示。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>这种残差跳跃式的结构，打破了传统的神经网络n-1层的输出只能给n层作为输入的惯例，使某一层的输出可以直接跨过几层作为后面某一层的输入，其意义在于为叠加多层网络而使得整个学习模型的错误率不降反升的难题提供了新的方向。<br>至此，神经网络的层数可以超越之前的约束，达到几十层、上百层甚至千层，为高级语义特征提取和分类提供了可行性。<br><img src="/2022/08/25/resnet/5.png" alt>完整的resnet的网络结构非常壮观。</p><h2 id="不同通道连接"><a href="#不同通道连接" class="headerlink" title="不同通道连接"></a>不同通道连接</h2><p>从图可以看出，怎么有一些“shortcut connections（捷径连接）”是实线，有一些是虚线，有什么区别呢？<br><img src="/2022/08/25/resnet/6.png" alt><br>因为经过“shortcut connections（捷径连接）”后，H(x)=F(x)+x，如果F(x)和x的通道相同，则可直接相加，那么通道不同怎么相加呢。对通道数不同的情况，只需要通过卷积操作改变通道数即可。上图中的实线、虚线就是为了区分这两种情况的：</p><p>实线的Connection部分，表示通道相同，如上图的第一个粉色矩形和第三个粉色矩形，都是3x3x64的特征图，由于通道相同，所以采用计算方式为H(x)=F(x)+x<br>虚线的的Connection部分，表示通道不同，如上图的第一个绿色矩形和第三个绿色矩形，分别是3x3x64和3x3x128的特征图，通道不同，采用的计算方式为H(x)=F(x)+Wx，其中W是卷积操作，用来调整x维度的。</p><h2 id="resnet-v2"><a href="#resnet-v2" class="headerlink" title="resnet v2"></a>resnet v2</h2><p>ResNet V2 和 ResNet V1 的主要区别在于，作者通过研究 ResNet 残差学习单元的传播公式，发现前馈和反馈信号可以直接传输，因此“shortcut connection”（捷径连接）的非线性激活函数（如ReLU）替换为 Identity Mappings。同时，ResNet V2 在每一层中都使用了 Batch Normalization。这样处理后，新的残差学习单元比以前更容易训练且泛化性更强。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SEnet</title>
      <link href="/2022/08/22/SEnet/"/>
      <url>/2022/08/22/SEnet/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-22 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>卷积神经网络的核心构件是卷积算子，它可以通过融合每一层局部接受域内的空间信息和信道信息来构建信息特征。<br>先前的研究主要是加强网络对空间尺度内的表示能力。而SEnet更关注通道间的关系。设计了一种SE块<br>这种SE块既可以堆叠成一个网络用来完成相关任务，也可以在现有模型中加入这种通道注意力的机制用来提高原始模型的表示能力</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>首先输入神经网络的图或是特征图的尺度如下<img src="/2022/08/22/SEnet/3.png" alt><br>先前的神经网络的工作都是在空间（HW）尺度内改进网络的效果。如何在空间尺度内改进网络效果呢？<br>首先回顾一下卷积<br>放一张卷积与全连接的对比图<br><img src="/2022/08/22/SEnet/4.png" alt><br><img src="/2022/08/22/SEnet/5.png" alt><br>对比发现，卷积相较于全连接。首先就是可以直观的表示特征。与卷积核相似度高的区域得分会更高。<br>卷积的参数更少，这可以增加网络的鲁棒性。<br>但是卷积相较于全连接的缺点也很明显。卷积的提取出的特征并不是全局的特征，受卷积的感受野的限制<br>那么如何在空间尺度上提升网络的性能呢？<br>很显而易见的是增加网络的感受野，使得提取出的特征尽可能是全局特征。<br>增加感受野的方法如下：下采样（池化），增大卷积核，加深网络<br>VGG使用减小卷积核的方法在增大感受野的同时减少参数<br><img src="/2022/08/22/SEnet/6.png" alt><br>为了解决在加深网络的同时带来的问题，resnet引入了残差模块，highwaynet与之类似。<br><img src="/2022/08/22/SEnet/7.png" alt></p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>之前的研究表明加深网络的深度可以增强网络的表示能力。为了加深网络出现了一些方法。比如vgg使用小卷积核增加网络深度，使用Batch Normalization (BN)来加快网络的学习速度。<br>ResNeT加入残差块，HighNet使用门控机制来调节一些层的信息会走捷径（一些信息不经过卷积层直接来到下一层）。分组卷积增加卷积次数增加卷积深度。</p><h2 id="注意力门控机制"><a href="#注意力门控机制" class="headerlink" title="注意力门控机制"></a>注意力门控机制</h2><p>注意力机制可以被解释为将一些可计算资源不按照平均分配而是将最多的计算资源分配到信息最丰富的部分中的一种手段。文中的SE块就是一种注意力门控机制</p><h2 id="SQUEEZE-AND-EXCITATION-BLOCKS"><a href="#SQUEEZE-AND-EXCITATION-BLOCKS" class="headerlink" title="SQUEEZE-AND-EXCITATION BLOCKS"></a>SQUEEZE-AND-EXCITATION BLOCKS</h2><p><img src="/2022/08/22/SEnet/1.png" alt><br>如图所示，SQUEEZE-AND-EXCITATION BLOCKS是在卷积操作之后，先压缩成一个C维的向量，再对这个向量进行激活得到一个权重向量。并将这个这个权重作为对输出结果C的权重。得到校准后的结果可以直接作为下一层的输入。</p><h3 id="SQUEEZE"><a href="#SQUEEZE" class="headerlink" title="SQUEEZE"></a>SQUEEZE</h3><p>Squeeze部分就是对每个通道进行全局聚合。SEnet使用全局平均池化，也可以使用其他更复杂的聚合方式，但是使用这种简单的聚合方式已经可以提升网络的性能。</p><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>SE块中的激活函数需要满足两个条件：<br>1.这个激活需要是非线性的，2，这个激活应该是非互斥的（即应该允许出现多个通道可以被高响应的而不是只有一个通道被高响应）</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><img src="/2022/08/22/SEnet/8.png" alt><br><img src="/2022/08/22/SEnet/9.png" alt><br>se块在VGG和RESNET中的应用。</p><h2 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2><h3 id="减速比"><a href="#减速比" class="headerlink" title="减速比"></a>减速比</h3><p><img src="/2022/08/22/SEnet/10.png" alt><br>比较效果时观察准确率的同时还应注重参数量和计算速度。综合两个结果</p><h3 id="聚合方式"><a href="#聚合方式" class="headerlink" title="聚合方式"></a>聚合方式</h3><p><img src="/2022/08/22/SEnet/11.png" alt><br>最大池化可以提取特征纹理， 最大池化提取边缘等“最重要”的特征</p><p>平均池化可以保留背景信息，平均池化提取的特征更加smoothly</p><p>ResNet在输入全连接层之前利用Kernel Size=7的AvgPooling来降维。反之为了减少无用信息的影响时用maxpool。网络浅层用maxpooling来进行降维。</p><p>但是全局平均池化的窗口太大了尤其浅层使用GMP其中一个像素点对应的感受野非常小。不能捕捉到全局信息。</p><p>CAM提到，在分类问题中gmp和gap并看不出孰优孰劣。但是要让卷积神经网络的对其分类结果给出一个合理解释，必须要充分利用好最后一个卷积层。GAP相较于GMP来说更充分的利用了空间信息</p><p>文章中处于对全局信息的考虑使用了GAP</p><h3 id="使用位置"><a href="#使用位置" class="headerlink" title="使用位置"></a>使用位置</h3><p><img src="/2022/08/22/SEnet/12.png" alt><br>resnet的四个阶段中使用，效果可以叠加。因为卷积神经网络深层浅层具有不同的效果。浅层神经网络提取类无关的特征。深层卷积网络作用是提取抽象的类相关的特征。因此四个阶段中的SE模块也有不同的作用</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>为什么Sigmoid效果最好，原文中提到：需要的激活函数应具备两个性质：<br>1.需要非线性<br>2.需要同时确保多个通道同时具有较高的权重，而不是只有一个通道获得高权重。<br>对比两个激活函数sigmoid函数将值限定在0-1之间，不会出现特别大的值分走过多的权重。<br><img src="/2022/08/22/SEnet/13.png" alt><br><img src="/2022/08/22/SEnet/14.png" alt><br><img src="/2022/08/22/SEnet/15.png" alt></p><h2 id="SE块的插入位置"><a href="#SE块的插入位置" class="headerlink" title="SE块的插入位置"></a>SE块的插入位置</h2><p><img src="/2022/08/22/SEnet/16.png" alt><br><img src="/2022/08/22/SEnet/17.png" alt><br>由结果看出，SE块需要插入在分支聚合前</p><h2 id="SE-3-3"><a href="#SE-3-3" class="headerlink" title="SE_3*3"></a>SE_3*3</h2><p><img src="/2022/08/22/SEnet/18.png" alt><br><img src="/2022/08/22/SEnet/19.png" alt><br>目的减少参数，将SE块放在中间通道少的地方，准确率略微下降，但是参数量显著减少。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VGG</title>
      <link href="/2022/08/20/VGG/"/>
      <url>/2022/08/20/VGG/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-20 16:57:17</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h2 id="VGG网络动机"><a href="#VGG网络动机" class="headerlink" title="VGG网络动机"></a>VGG网络动机</h2><p>通过使用小卷积核代替大卷积核的方法，不改变感受野的同时减小网络参数。具体来说，vgg中使用三个3<em>3大小的卷积核代替7<strong>7的卷积核，使用两个3</strong>3的卷积核代替5*</em>5的卷积核。<br>这样做感受野不变的同时，增加了网络的深度，同时每层小卷积核后面都有RELU激活函数，（增加了激活层的个数）使网络引入更多非线性层。</p><h2 id="VGG的优缺点"><a href="#VGG的优缺点" class="headerlink" title="VGG的优缺点"></a>VGG的优缺点</h2><h3 id="VGG的优点"><a href="#VGG的优点" class="headerlink" title="VGG的优点"></a>VGG的优点</h3><p>VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（3x3）和最大池化尺寸（2x2）。<br>几个小滤波器（3x3）卷积层的组合比一个大滤波器（5x5或7x7）卷积层好：<br>验证了通过不断加深网络结构可以提升性能。</p><h3 id="VGG的缺点"><a href="#VGG的缺点" class="headerlink" title="VGG的缺点"></a>VGG的缺点</h3><p>VGG耗费更多计算资源，并且使用了更多的参数（这里不是3x3卷积的锅），导致更多的内存占用（140M）。其中绝大多数的参数都是来自于第一个全连接层。而且据其他人的实验可得<br>去掉这些全连接层并不会使网络效果变差。<br><img src="/2022/08/20/VGG/a.jpg" alt></p><h2 id="rule函数"><a href="#rule函数" class="headerlink" title="rule函数"></a>rule函数</h2><p>relu函数相较于sigmoid函数，梯度只有0，1.缓解了网络较深时梯度消失的问题。同时0代表网络节点未被激活使得网络具有一定的稀疏性。也可以抑制过拟合现象。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GoogLeNet</title>
      <link href="/2022/08/20/GoogLeNet/"/>
      <url>/2022/08/20/GoogLeNet/</url>
      
        <content type="html"><![CDATA[<hr><p>date: 2022-08-20 16:33:46</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h2 id="网络动机"><a href="#网络动机" class="headerlink" title="网络动机"></a>网络动机</h2><p>  提高网络性能最直接的方法就是增加网络尺寸。但是扩大网络会带来一些影响：<br>1.扩大神经网络会使得网络容易过拟合<br>2.神经网络较多参数会消耗较多的计算资源。文中提出了以下解决方案：<br>1。将全连接以及卷积层变为稀疏连接，2。同时使用了dropout的方法共同减少网络参数。<br>3.使用Max Pool和Average Pool。<br>4.使用Network in Network方法，增加网络的表现能力，这种方法可以看做是一个额外的1*1卷积层再加上一个ReLU层。NIN最重要的是降维，解决了计算瓶颈，从而解决网络尺寸受限的问题。这样就可以增加网络的深度和宽度了，而且不会有很大的性能损失。<br>5.当前最好的对象检测方法是R-CNN。R-CNN将检测问题分解为两个子问题：首先利用低级特征（颜色和超像素一致性）在分类不可知时寻找潜在目标，然后使用CNN分类器识别潜在目标所属类别。GoogLeNet在这两个阶段都进行了增强效果。</p><h2 id="GoogLeNet架构细节"><a href="#GoogLeNet架构细节" class="headerlink" title="GoogLeNet架构细节"></a>GoogLeNet架构细节</h2><p><img src="/2022/08/20/GoogLeNet/a.png" alt><br><img src="/2022/08/20/GoogLeNet/b.png" alt><br>图(a)是传统的多通道卷积操作，图(b)是GoogLeNet中使用的Inception模块，两者的区别在于：</p><p>Inception使用了多个不同尺寸的卷积核，还添加了池化，然后将卷积和池化结果串联在一起。<br>卷积之前有1×1的卷积操作，池化之后也有1×1的卷积操作。<br>Inception模块中的多尺寸卷积核的卷积卷积过程和普通卷积过程不同。<br>第一点不同的原因是：Inception的主要思想就是如何找出最优的局部稀疏结构并将其覆盖为近似的稠密组件，这里就是将不同的局部结构组合到了一起。<br>第二点不同的原因是：原始的卷积是广义线性模型GLM(generalized linear model)，GLM的抽象等级较低，无法很好的表达非线性特征，这种1×1的卷积操作将高相关性的节点聚集在一起。什么是高相关性节点呢？两张特征图中相同位置的节点就是相关性高的节点。假设当前层的输入大小是28×28×256，卷积核大小为1×1×256，卷积得到的输出大小为28×28×1。可以看出这种操作一方面将原来的线性模型变成了非线性模型，将高相关性节点组合到了一起，具有更强的表达能力，另一方面减少了参数个数</p><h2 id="辅助分类器"><a href="#辅助分类器" class="headerlink" title="辅助分类器"></a>辅助分类器</h2><p>神经网络的中间层也具有很强的识别能力，为了利用中间层抽象的特征，在某些中间层中添加含有多层的分类器。<br><img src="/2022/08/20/GoogLeNet/c.png" alt></p><h2 id="GoogLeNet网络架构"><a href="#GoogLeNet网络架构" class="headerlink" title="GoogLeNet网络架构"></a>GoogLeNet网络架构</h2><p><img src="/2022/08/20/GoogLeNet/d.png" alt><br>GoogLeNet神经网络中，使用了前两节提到的Inception模块和辅助分类器，而且由于全连接网络参数多，计算量大，容易过拟合，所以GoogLeNet没有采用AlexNet（2012年ImageNet冠军队使用的网络结构，前五层是卷积层，后三层是全连接层）中的全连接结构，直接在Inception模块之后使用Average Pool和Dropout方法，不仅起到降维作用，还在一定程度上防止过拟合。<br>在Dropout层之前添加了一个7×7的Average Pool，一方面是降维，另一方面也是对低层特征的组合。我们希望网络在高层可以抽象出图像全局的特征，那么应该在网络的高层增加卷积核的大小或者增加池化区域的大小，GoogLeNet将这种操作放到了最后的池化过程，前面的Inception模块中卷积核大小都是固定的，而且比较小，主要是为了卷积时的计算方便。<br>第二幅图中蓝色部分是卷积块，每个卷积块后都会跟一个ReLU（受限线性单元）层作为激活函数（包括Inception内部的卷积块）</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>训练7个GoogLeNet模型，其中包含一个加宽版本，其余6个模型初始化和超参数都一样，只是采样方法和样本顺序不同<br>采用模型和数据并行技术，用几个高端GPU训练一周可得到收敛(估算)<br>多个模型的训练是不同步的，超参数的变化也是不一样的，比如dropout和学习率<br>有些模型主要训练小尺寸样本，有些模型训练大尺寸样本<br>采样时，样本尺寸缩放从8%到100%，宽高比随机选取3/4或4/3（多尺度）<br>将图像作光度扭曲，也就是随机更改图像的对比度，亮度和颜色。这样可以增加网络对这些属性的不变性<br>使用随机插值方法重置图像尺寸（因为网络输入层的大小是固定的），<br>使用到的随机插值方法：双线性插值，区域插值，最近邻插值，三次方插值，这些插值方法等概率的被选择使用。图像放大时，像素也相应地增加 ，增加的过程就是“插值”程序自动选择信息较好的像素作为增加的像素，而并非只使用临近的像素，所以在放大图像时，图像看上去会比较平滑、干净<br>改变超参数（反向传播若干次之后改变超参数，或者误差达到某阈值时改变超参数）</p><h2 id="测试样本处理"><a href="#测试样本处理" class="headerlink" title="测试样本处理"></a>测试样本处理</h2><p>对于一个测试样本，将图像的短边缩放成4种尺寸，分别为256，288，320，352。<br>从每种尺寸的图像的左边，中间，右边（或者上面，中间，下面）分别截取一个方形区域。<br>从每个方形区域的4个拐角和中心分别截取一个224×224区域，再将方形区域缩小到224×224，这样每个方形区域能得到6张大小为224×224的图像，加上它们的镜像版本（将图像水平翻转），一共得到4×3×6×2=144张图像。</p><h1 id><a href="#" class="headerlink" title="#"></a>#</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/19/hello-world/"/>
      <url>/2022/08/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
