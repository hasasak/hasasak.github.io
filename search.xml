<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/08/03/%E5%88%A0%E9%99%A4%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A/"/>
      <url>/2023/08/03/%E5%88%A0%E9%99%A4%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-删除注释"><a href="#title-删除注释" class="headerlink" title="title:删除注释"></a>title:删除注释</h2><p>date: 2022-08-22 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="删除代码中的注释"><a href="#删除代码中的注释" class="headerlink" title="删除代码中的注释"></a>删除代码中的注释</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>使用C++中的正则表达式需要引用头文件<regex>。C++标准库中提供了std::regex类来支持正则表达式的操作。</regex></p><p>正则表达式匹配邮箱地址示例</p><p>std::regex pattern(R”(\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*)”);</p><p>其中，R”()”表示将字符串标记为“Raw String”，使得字符串内的特殊字符能够直接被解释而不需要转义。正则表达式中常用的一些特殊字符有：.表示任意一个字符；^<br>表示匹配开头；$表示匹配结尾；*表示匹配0到多个字符；+表示匹配1到多个字符；{n}表示匹配n个字符；{n, m}表示匹配n到m个字符。</p><p>然后，我们可以使用std::regex_match()函数来匹配一个字符串是否符合给定的正则式<br>std::regex_match()会返回一个布尔值。表示是否匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; regex_match(&quot;123&quot;, regex(&quot;\d+&quot;)) &lt;&lt; endl;    //结果为0，需要转义字符&#x27;\&#x27;</span><br><span class="line">cout &lt;&lt; regex_match(&quot;123&quot;, regex(&quot;\\d+&quot;)) &lt;&lt; endl;    //结果为1，完全匹配</span><br></pre></td></tr></table></figure><p>std::regex类提供了很多函数来支持正则表达式的匹配操作。下面是一些常用的函数:</p><p>std::regex_search(str, pattern)：查找给定字符串中第一个满足正则表达式要求的子串。</p><p>std::regex_replace(str, pattern, replacement)：将给定的字符串中匹配正则式的子字符串替换为指定字符串。</p><p>std::sregex_iterator it(str.begin(), str.end(), pattern)：遍历给定字符串中所有匹配正则式的子串。</p><p>std::regex构造函数中可以添加一个参数，用来指定标志。</p><p>std::regex_constants::icase：不区分大小写匹配。<br>std::regex_constants::ECMAScript：使用ECMAScript引擎，支持UTF-8编码。<br>std::regex_constants::extended：使用扩展正则表达式语法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string str(&quot;Hello, World!&quot;);</span><br><span class="line">std::regex pattern(R&quot;(world)&quot;, std::regex_constants::icase);</span><br><span class="line">if (std::regex_search(str, pattern)) &#123;  // true</span><br><span class="line">    std::cout &lt;&lt; &quot;Matched!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第 i 行源码。 这表示每行源码由 ‘\n’ 分隔。</p><p>在 C++ 中有两种注释风格，行内注释和块注释。</p><p>字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。<br>字符串/<em> 表示一个块注释，它表示直到下一个（非重叠）出现的</em>/之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串/*/并没有结束块注释，因为注释的结尾与开头相重叠。<br>第一个有效注释优先于其他注释。</p><p>如果字符串//出现在块注释中会被忽略。<br>同样，如果字符串/*出现在行或块注释中也会被忽略。<br>如果一行在删除注释之后变为空字符串，那么不要输出该行。即，答案列表中的每个字符串都是非空的。</p><p>样例中没有控制字符，单引号或双引号字符。</p><p>比如，source = “string s = “/<em> Not a comment. </em>/“;” 不会出现在测试样例里。<br>此外，没有其他内容（如定义或宏）会干扰注释。</p><p>我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的/*总是开始新的注释。</p><p>最后，隐式换行符可以通过块注释删除。 有关详细信息，请参阅下面的示例。</p><p>从源代码中删除注释后，需要以相同的格式返回源代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; removeComments(vector&lt;string&gt;&amp; source) &#123;</span><br><span class="line">      string str;</span><br><span class="line">        int n=source.size();</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str+=source[i];</span><br><span class="line">            str+=&#x27;\n&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">       string s=regex_replace(str,regex(&quot;//.*|/\\*(.|\n)*?\\*/&quot;),&quot;&quot;);</span><br><span class="line">       vector&lt;string&gt;ans;</span><br><span class="line">        string t;</span><br><span class="line">        for(int i=0;i&lt;s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]==&#x27;\n&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                if(t!=&quot;&quot;)ans.push_back(t);</span><br><span class="line">                t=&quot;&quot;;</span><br><span class="line">            &#125;   </span><br><span class="line">            else t+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>“//.<em>|/\</em>(.|\n)<em>?\</em>/“即为对应的正则表达式：</p><p>//表示//<br>.表示注释里面的任意字符<em>表示匹配任意数量的.字符|表示逻辑或/表示注释中的/，\</em>表示转义后的raw <em>。()表示设定分组。(.|\n)表示<br>任意的字符串或者换行符加上？是因为</em>表示1个或多个，但是也可能存在零个？表示零个或一个。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性扫描</title>
      <link href="/2023/08/03/%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F/"/>
      <url>/2023/08/03/%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-22 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="线性扫描解决数组中最大乘积😄"><a href="#线性扫描解决数组中最大乘积😄" class="headerlink" title="线性扫描解决数组中最大乘积😄"></a>线性扫描解决数组中最大乘积😄</h1><h2 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h2><p>遍历数组更新需要的值</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个数组，求数组中任意三个数的乘积的最大值，乘积不会越界</p><p>两个最小的负数和一个最大的正数。三个最大的正数</p><p>排序</p><figure class="highlight plaintext"><figcaption><span>Solution &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        return max(nums[0] * nums[1] * nums[n - 1], nums[n - 3] * nums[n - 2] * nums[n - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>扫描<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int min1 = nums[0];</span><br><span class="line">        int min2;</span><br><span class="line">        int max1= nums[0];</span><br><span class="line">        int max2;</span><br><span class="line">        int max3;</span><br><span class="line">        int a ;</span><br><span class="line">        int b ;</span><br><span class="line">        if (nums[1]&gt;nums[0])&#123;</span><br><span class="line">            min2 = nums[1];</span><br><span class="line">            max2= nums[0];</span><br><span class="line">            max1 = nums[1];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            max2 = nums[1];</span><br><span class="line">            min1 = nums[1];</span><br><span class="line">            min2 = nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[2]&gt;max1)&#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 =max1;</span><br><span class="line">            max1 = nums[2];</span><br><span class="line">        &#125;</span><br><span class="line">        else if(nums[2]&gt;max2)&#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2  = nums[2];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            max3 = nums[2];</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[2]&lt;min1)&#123;</span><br><span class="line">            min2 = min1;</span><br><span class="line">            min1 = nums[2];</span><br><span class="line">        &#125;</span><br><span class="line">        else if (nums[2]&lt;min2)&#123;</span><br><span class="line">            min2 = nums[2];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=3;i&lt;nums.size();i++)&#123;</span><br><span class="line">            if(nums[i]&lt;min1)&#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i]&lt;min2)&#123;</span><br><span class="line">                min2 = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i]&gt;max1)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i]&gt;max2)&#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 =  nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i]&gt;max3)&#123;</span><br><span class="line">                max3 = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a = min1*min2*max1;</span><br><span class="line">        b  = max1*max2*max3;</span><br><span class="line">        cout &lt;&lt;max1&lt;&lt;max2&lt;&lt;max3&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt;min1&lt;&lt;min2&lt;&lt;endl;</span><br><span class="line">        if(a&gt;b)&#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>写的非常长，初始化max123和min123的时候写了很乱的代码。</p><p>官方题解代码</p><figure class="highlight plaintext"><figcaption><span>Solution &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    int maximumProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        // 最小的和第二小的</span><br><span class="line">        int min1 = INT_MAX, min2 = INT_MAX;</span><br><span class="line">        // 最大的、第二大的和第三大的</span><br><span class="line">        int max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;</span><br><span class="line"></span><br><span class="line">        for (int x: nums) &#123;</span><br><span class="line">            if (x &lt; min1) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = x;</span><br><span class="line">            &#125; else if (x &lt; min2) &#123;</span><br><span class="line">                min2 = x;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (x &gt; max1) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = x;</span><br><span class="line">            &#125; else if (x &gt; max2) &#123;</span><br><span class="line">                max3 = max2;</span><br><span class="line">                max2 = x;</span><br><span class="line">            &#125; else if (x &gt; max3) &#123;</span><br><span class="line">                max3 = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max(min1 * min2 * max1, max1 * max2 * max3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化max为INT_MIN//int的最小值 min为最大值。不需要手动初始化三个最大值与两个最小值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希两数之和</title>
      <link href="/2023/08/03/leetcode%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/08/03/leetcode%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-22 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="leecode-c-simplest-diary"><a href="#leecode-c-simplest-diary" class="headerlink" title="leecode c++ simplest diary"></a>leecode c++ simplest diary</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><h3 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; r(0,0);</span><br><span class="line">        for (int i = 0;i&lt;nums.size()-2;++i)&#123;</span><br><span class="line">            for (int j = i + 1 ;j&lt;nums.size()-1;++j)&#123;</span><br><span class="line">                if (i + j == target)&#123;</span><br><span class="line">                    r[0]=i;</span><br><span class="line">                    r[1]=j;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用hashtable"><a href="#使用hashtable" class="headerlink" title="使用hashtable"></a>使用hashtable</h3><p>c++ hashtable 由 unordered_maps 实现，分别使用 insert在哈希表中插入元素<br>使用find 方法查找哈希表对应元素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        std::unordered_map&lt;int,int&gt; nums_map;//unordered_map实现哈希表</span><br><span class="line">        for(int i=0;i&lt;nums.size();++i)&#123;</span><br><span class="line">            auto it = nums_map.find(target-nums[i]);//it为结构体指针</span><br><span class="line">            if(it != nums_map.end())&#123;</span><br><span class="line">                return &#123;it-&gt;second, i&#125;;//first指向 key，second指向value</span><br><span class="line">            &#125;</span><br><span class="line">            nums_map[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表相加</title>
      <link href="/2023/08/03/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2023/08/03/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-22 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="链表两数之和"><a href="#链表两数之和" class="headerlink" title="链表两数之和"></a>链表两数之和</h1><p><img src="/2023/08/03/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/两数相加.png" alt="两数相加"></p><p>head为输出结果头节点</p><p>now维当前操作节点</p><p>最后如果需要进位则判断进位是否为零不为零则new一个节点作为首位<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *head = nullptr ;</span><br><span class="line">        ListNode *now = nullptr;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        while(l1||l2)&#123;</span><br><span class="line">            int n1 = l1? l1 -&gt; val :0;</span><br><span class="line">            int n2 = l2? l2 -&gt; val :0;</span><br><span class="line">            int sum = n1+n2+carry;</span><br><span class="line">            if (!head)&#123;</span><br><span class="line">                head = new ListNode(sum%10);</span><br><span class="line">                now =head;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                now -&gt;next = new ListNode(sum%10);</span><br><span class="line">                now = now -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry =sum/10;</span><br><span class="line">            if(l1)&#123;</span><br><span class="line">                l1 = l1 -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            if(l2)&#123;</span><br><span class="line">                l2 = l2 -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if (carry&gt;0)&#123;</span><br><span class="line">            now -&gt;next =new ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2023/08/03/%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/"/>
      <url>/2023/08/03/%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-22 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="递归线性问题的快速幂计算"><a href="#递归线性问题的快速幂计算" class="headerlink" title="递归线性问题的快速幂计算"></a>递归线性问题的快速幂计算</h1><h2 id="示例：斐波那契数列"><a href="#示例：斐波那契数列" class="headerlink" title="示例：斐波那契数列"></a>示例：斐波那契数列</h2><p>f(x)=f(x-1)+f(x-2);f(0)=1;f(1)=2;</p><h3 id="递归计算斐波那契数列"><a href="#递归计算斐波那契数列" class="headerlink" title="递归计算斐波那契数列"></a>递归计算斐波那契数列</h3><p>矩阵形式如下</p><p><img src="/2023/08/03/%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/快速幂.png" alt="快速幂"></p><p>因此</p><p><img src="/2023/08/03/%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/快速幂1.png" alt="快速幂1"></p><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂计算原理<br>暂存幂运算的中间值；<br>示例计算2的15次方</p><p><img src="/2023/08/03/%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/快速幂2.png" alt="快速幂1"></p><p>为什么会快<br>传统计算过程为连乘15-1次</p><p>快速幂计算流程：1，保存2的一次方</p><p>2.将2的一次方乘2的一次方得到2的二次方，并与之前的计算结果相乘</p><p>3.同理计算次数为2+2+2 = 6次</p><p>矩阵快速幂同理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最长不重复子串</title>
      <link href="/2023/08/03/%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/08/03/%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-22 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/2023/08/03/%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/最长不重复子串.png" alt="图示"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int a=0;</span><br><span class="line">        int b=0;</span><br><span class="line">        int len = 1;</span><br><span class="line">        if (s.size()==0)&#123;//s为零时；</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        while(b&lt;s.size()-1)&#123;</span><br><span class="line">            b = b+1;</span><br><span class="line">            for (int i=a;i&lt;b;i++)&#123;</span><br><span class="line">                if (s[i]==s[b])&#123;</span><br><span class="line">                    a = i+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (b-a+1&gt;len)&#123;</span><br><span class="line">            len = b-a+1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2023/08/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/08/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-22 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>基础题反转链表</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight plaintext"><figcaption><span>Solution &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode *pre = nullptr;</span><br><span class="line">        ListNode *curr = head;</span><br><span class="line">        while (curr)&#123;</span><br><span class="line">            ListNode* next = curr -&gt;next;</span><br><span class="line">            curr -&gt;next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路，反转链表就是将每一个listnode的next变为这个node的pre；所以我们需要记下pre，记下当前node并令node-&gt;next=pre；此外由于链表的下一节点地址会<br>因此丢失，因此我们需要提前保留下next节点的地址</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        if(!head||!head -&gt;next)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newhead = reverseList(head-&gt;next);</span><br><span class="line">        head -&gt;next -&gt;next = head;</span><br><span class="line">        head -&gt;next = nullptr;</span><br><span class="line">        return newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最长有效括号</title>
      <link href="/2023/08/03/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>/2023/08/03/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-22 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h1><h2 id="边界条件与转移矩阵"><a href="#边界条件与转移矩阵" class="headerlink" title="边界条件与转移矩阵"></a>边界条件与转移矩阵</h2><p><img src="/2023/08/03/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/有效括号.png" alt="有效括号"><br>边界条件：寻找最短有效括号（）dp[i][j=i+1]意为是否为最短有效括号</p><p>转移方式：当dp[i][j]为有效括号，且dp[j+1][j+2]为有效括号则dp[i][j+2]为有效括号</p><p>当dp[i][j]为有效括号，且s[i-1]与s[j+1]为有效括号，则dp[i-1][j+1]为有效括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int longestValidParentheses(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        int maxlen = 0;</span><br><span class="line">        int begin = 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp (n,vector&lt;int&gt;(n));</span><br><span class="line">        if (n&lt;2)&#123;</span><br><span class="line">            return maxlen;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0;i&lt;n-1;i++)&#123;</span><br><span class="line">            if (s[i]==&#x27;(&#x27;&amp;&amp; s[i+1]==&#x27;)&#x27;)&#123;</span><br><span class="line">                dp[i][i+1] = true;</span><br><span class="line">                maxlen = 2;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                dp[i][i+1]=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j=4;j&lt;=n;j=j+2)&#123;</span><br><span class="line">            for (int k = 0;k&lt;n;k++)&#123;</span><br><span class="line">                int m = k+j-1;</span><br><span class="line">                if (m&gt;=n)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (s[k]==&#x27;(&#x27;&amp;&amp;s[m]==&#x27;)&#x27;&amp;&amp;dp[k+1][m-1])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[k][m]=true;</span><br><span class="line">                &#125;</span><br><span class="line">                for (int z = k;z&lt;m;z++)&#123;</span><br><span class="line">                    if(dp[k][z]==true&amp;&amp;dp[z+1][m]==true)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[k][m]=true;</span><br><span class="line">                                       &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if ( dp[k][m]==true)&#123;</span><br><span class="line">                    if((m-k+1)&gt;maxlen)&#123;</span><br><span class="line">                        maxlen = m-k+1;</span><br><span class="line">                        begin = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果超时了。。。。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>动态规划官方题解只建立了一个一维的转移矩阵原因就是知道连续的括号的结尾的话，是可以直接算出来开头的，所以建立二维的向量很浪费。</p><p>括号可以用栈很简单的做出来</p><p>利用括号的性质，设置left和right计数器。从左至右遍历right大于left则为无效括号将计数器归零。当right等于left时记下最长长度。但是这样做当右括号多于左括号时无结果，因此还要从右至左反方向遍历一遍，此时判断条件与之前相反，取两次遍历的最大值作为输出结果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dp回文子串</title>
      <link href="/2023/08/03/dp%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/08/03/dp%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>date: 2023-08-3 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="leecode-c-dp-diary"><a href="#leecode-c-dp-diary" class="headerlink" title="leecode c++ dp diary"></a>leecode c++ dp diary</h1><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><img src="/2023/08/03/dp%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/huiwen.png" alt="图片"></p><p>状态转移图示;转移步骤分三步：<br>1.m[i][i]=1;<br>2.判断m[i][i+1]是否为回文子串；<br>3.沿箭头方向判断是否为回文字串；<br>状态转移类似于记忆化搜索，需要保留中间结果以减少计算时间，因此需要沿箭头方向遍历。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        int maxlen = 1;//记录最大长度</span><br><span class="line">        int begin=0;//记录起始位置</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n&lt;2)&#123;//字符串长度为1时本身为最大字串</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; p(n, vector&lt;int&gt;(n));定义转移矩阵</span><br><span class="line">        for (int i = 0 ;i&lt;n;i++)&#123;//边界条件1</span><br><span class="line">            p[i][i]= true;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int q = 0 ;q&lt;n-1;q++)&#123;//边界条件2</span><br><span class="line">            if (s[q]==s[q+1])&#123;</span><br><span class="line">                p[q][q+1]= true;</span><br><span class="line">                maxlen = 2;//更新最大长度</span><br><span class="line">                begin = q;//更新初始位置</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                p[q][q+1]= false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int l = 3;l&lt;=n;l++)&#123;//从长度为3开始遍历</span><br><span class="line">            for(int left = 0;left&lt;n;left++)&#123;//左边界0-n</span><br><span class="line">                int right = left+l-1;//计算右边界</span><br><span class="line">                if (right&gt;=n)&#123;//判断是否出界</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (s[left]!=s[right])&#123;//左右不相等则为flase</span><br><span class="line">                    p[left][right]=false;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;//左右相等则查询箭头反方向是否为回文字串</span><br><span class="line">                    p[left][right] = p[left+1][right-1];</span><br><span class="line">                &#125;</span><br><span class="line">                if (p[left][right] &amp;&amp; right - left + 1 &gt; maxlen) &#123;//更新maxlen和begin</span><br><span class="line">                    maxlen = right - left + 1;</span><br><span class="line">                    begin = left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substr(begin,maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>R-CNN FastRCNN FasterRCNN</title>
      <link href="/2022/09/14/R-CNN-FastRCNN-FasterRCNN/"/>
      <url>/2022/09/14/R-CNN-FastRCNN-FasterRCNN/</url>
      
        <content type="html"><![CDATA[<h2 id="IOU-Intersection-over-Union"><a href="#IOU-Intersection-over-Union" class="headerlink" title="IOU(Intersection over Union)"></a>IOU(Intersection over Union)</h2><p> IoU是一种测量在特定数据集中检测相应物体准确度的一个标准。IoU是一个简单的测量标准，只要是在输出中得出一个预测范围(bounding boxex)的任务都可以用IoU来进行测量。为了可以使IoU用于测量任意大小形状的物体检测，我们需要：</p><p>ground-truth bounding boxes（人为在训练集图像中标出要检测物体的大概范围）<br>我们的算法得出的结果范围。<br>       也就是说，这个标准用于测量真实和预测之间的相关度，相关度越高，该值越高。如下图所示。绿色标线是人为标记的正确结果（ground-truth），红色标线是算法预测的结果（predicted）。</p><h2 id="RCNN"><a href="#RCNN" class="headerlink" title="RCNN"></a>RCNN</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>RCNN算法分为4个步骤</p><p>一张图像生成1K~2K个候选区域<br>对每个候选区域，使用深度网络提取特征<br>特征送入每一类的SVM 分类器，判别是否属于该类<br>使用回归器精细修正候选框位置</p><h3 id="候选区域生成"><a href="#候选区域生成" class="headerlink" title="候选区域生成"></a>候选区域生成</h3><p>使用了Selective Search1方法从一张图像生成约2000-3000个候选区域。基本思路如下：</p><p>使用一种过分割手段，将图像分割成小区域<br>查看现有小区域，合并可能性最高的两个区域。重复直到整张图像合并成一个区域位置<br>输出所有曾经存在过的区域，所谓候选区域<br>候选区域生成和后续步骤相对独立，实际可以使用任意算法进行。</p><h4 id="候选区域合并"><a href="#候选区域合并" class="headerlink" title="候选区域合并"></a>候选区域合并</h4><p>优先合并以下四种区域：</p><p>颜色（颜色直方图）相近的<br>纹理（梯度直方图）相近的<br>合并后总面积小的<br>合并后，总面积在其BBOX中所占比例大的<br>第三条，保证合并操作的尺度较为均匀，避免一个大区域陆续“吃掉”其他小区域。</p><h4 id="多样化与后处理"><a href="#多样化与后处理" class="headerlink" title="多样化与后处理"></a>多样化与后处理</h4><p>为尽可能不遗漏候选区域，上述操作在多个颜色空间中同时进行（RGB,HSV,Lab等）。在一个颜色空间中，使用上述四条规则的不同组合进行合并。所有颜色空间与所有规则的全部结果，在去除重复后，都作为候选区域输出。</p><h2 id="FastRCNN"><a href="#FastRCNN" class="headerlink" title="FastRCNN"></a>FastRCNN</h2><p>将候选区域生成这一步放到特征图之后，这样可以不对所有的候选区域都单独做一次前向传播</p><h2 id="FasterRCNN"><a href="#FasterRCNN" class="headerlink" title="FasterRCNN"></a>FasterRCNN</h2><p>核心思想是使用CNN卷积神经网络直接产生Region Proposal，使用的方法本质上就是滑动窗口（只需在最后的卷积层上滑动一遍），因为anchor机制和边框回归可以得到多尺度多长宽比的Region Proposal。</p><p>RPN网络也是全卷积网络（FCN，fully-convolutional network），可以针对生成检测建议框的任务端到端地训练，能够同时预测出object的边界和分数。只是在CNN上额外增加了2个卷积层（全卷积层cls和reg）。</p><p>①将每个特征图的位置编码成一个特征向量（256dfor ZF and 512d for VGG）。</p><p>②对每一个位置输出一个objectness score和regressedbounds for k个region proposal，即在每个卷积映射位置输出这个位置上多种尺度（3种）和长宽比（3种）的k个（3*3=9）区域建议的物体得分和回归边界。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>efficientnet</title>
      <link href="/2022/09/14/efficientnet/"/>
      <url>/2022/09/14/efficientnet/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对网络的扩展一般分为增加深度与增加宽度，efficientnet通过实验从depth, width, resolution 这三个维度去缩放模型。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shufflenet</title>
      <link href="/2022/09/14/Shufflenet/"/>
      <url>/2022/09/14/Shufflenet/</url>
      
        <content type="html"><![CDATA[<p>论文：ShuffleNet: An Extremely Efficient Convolutional Neural Network for Mobile Devices<br>论文链接：<a href="https://arxiv.org/abs/1707.01083">https://arxiv.org/abs/1707.01083</a></p><h2 id="算法详解："><a href="#算法详解：" class="headerlink" title="算法详解："></a>算法详解：</h2><p>ShuffleNet是一篇用于降低网络参数量的论文。ShuffleNet使用分组卷积的操作方式降低网络参数。分组卷积最早在Alexnet中使用。后续依次被resnet和<br>MobileNet借鉴。MobileNet使用了深度可分离卷积的方法减少了网络参数。具体方法是使用w<em>h</em>1的depthwise卷积和1<em>1</em>C的pointwise卷积。<br>其中depthwise卷积可以看作是分组数等于通道数的分组卷积。通过分组的方式减少网络的参数量。ShuffleNet在MobileNet的基础上。对point wise卷积也采用了分组卷积的方式<br>来减少point wise卷积的参数量。但是这样做会产生边界效应。即在最终的输出结果中有某些通道没有被计算。为了解决这个问题ShuffleNet使用了channel shuffle<br>的操作。如图所示使用通道重排的方式使得输出的特征图使用所有的通道来计算。<br><img src="/2022/09/14/Shufflenet/1.jpg" alt></p><h2 id="特征提取和下采样"><a href="#特征提取和下采样" class="headerlink" title="特征提取和下采样"></a>特征提取和下采样</h2><p><img src="/2022/09/14/Shufflenet/2.jpg" alt><br>Figure2（b）中的第一个1<em>1卷积是GConv，表示group convolution。Figure2（a）是ResNet中的bottleneck unit，不过将原来的3</em>3 Conv改成3<em>3 DWConv，作者的ShuffleNet主要也是在这基础上做改动。首先用带group的1</em>1卷积代替原来的1<em>1卷积，同时跟一个channel shuffle操作，这个前面也介绍过了。然后是3</em>3 DWConv表示depthwise separable convolution。depthwise separable convolution可以参考MobileNet，下面贴出depthwise separable convolution的示意图。Figure2（c）添加了一个Average pooling和设置了stride=2，另外原来Resnet最后是一个Add操作，也就是元素值相加，而在（c）中是采用concat的操作，也就是按channel合并，类似googleNet的Inception操作。</p><h2 id="与MobileNet相比的改进："><a href="#与MobileNet相比的改进：" class="headerlink" title="与MobileNet相比的改进："></a>与MobileNet相比的改进：</h2><p>作者认为mobilenet中的1*1的point wise卷积还是可以降低参数的，但是使用分组的方式降低参数会导致只有一部分通道参与计算，因此作者使用通道重排的方式改进这个缺点。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>densenet</title>
      <link href="/2022/08/25/densenet/"/>
      <url>/2022/08/25/densenet/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-25 09:19:53</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在深度学习网络中，随着网络深度的加深，梯度消失问题会愈加明显，目前很多论文都针对这个问题提出了解决方案，比如ResNet，Highway Networks，Stochastic depth，FractalNets等，尽管这些算法的网络结构有差别，但是核心都在于：create short paths from early layers to later layers。那么作者是怎么做呢？延续这个思路，那就是在保证网络中层与层之间最大程度的信息传输的前提下，直接将所有层连接起来！<br>dense block的结构图如下。在传统的卷积神经网络中，如果你有L层，那么就会有L个连接，但是在DenseNet中，会有L(L+1)/2个连接。简单讲，就是每一层的输入来自前面所有层的输出。<br><img src="/2022/08/25/densenet/1.jpg" alt></p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p>DenseNet的结构图，在这个结构图中包含了3个dense block。作者将DenseNet分成多个dense block，原因是希望各个dense block内的feature map的size统一，这样在做concatenation就不会有size的问题。<br><img src="/2022/08/25/densenet/2.jpg" alt><br>DenseNet和ResNet的一个明显区别是，ResNet是求和，而DenseNet是做一个拼接，每一层网络的输入包括前面所有层网络的输出。<br>整个网络的结构图。这个表中的k=32，k=48中的k是growth rate，表示每个dense block中每层输出的feature map个数。为了避免网络变得很宽，作者都是采用较小的k，比如32这样，作者的实验也表明小的k可以有更好的效果。根据dense block的设计，后面几层可以得到前面所有层的输入，因此concat后的输入channel还是比较大的。另外这里每个dense block的3<em>3卷积前面都包含了一个1</em>1的卷积操作，就是所谓的bottleneck layer，目的是减少输入的feature map数量，既能降维减少计算量，又能融合各个通道的特征，何乐而不为。另外作者为了进一步压缩参数，在每两个dense block之间又增加了1<em>1的卷积操作。因此在后面的实验对比中，如果你看到DenseNet-C这个网络，表示增加了这个Translation layer，该层的1</em>1卷积的输出channel默认是输入channel到一半。如果你看到DenseNet-BC这个网络，表示既有bottleneck layer，又有Translation layer。<br><img src="/2022/08/25/densenet/3.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DenseNet核心思想在于建立了不同层之间的连接关系，充分利用了feature，进一步减轻了梯度消失问题，加深网络不是问题，而且训练效果非常好。另外，利用bottleneck layer，Translation layer以及较小的growth rate使得网络变窄，参数减少，有效抑制了过拟合，同时计算量也减少了。DenseNet优点很多，而且在和ResNet的对比中优势还是非常明显的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>resnet</title>
      <link href="/2022/08/25/resnet/"/>
      <url>/2022/08/25/resnet/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-25 09:19:40</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>在卷积神经网络中，增加网络深度意味着增加网络的性能，但是这个性能不是无限增加的。当网络增加到一定深度后继续增加网络深度网络的性能可能会随之下降。这是由于神经网络传播过程中信息的丢失和损耗造成的。<br>同时还会有梯度消失或者梯度爆炸的现象。</p><h2 id="概括："><a href="#概括：" class="headerlink" title="概括："></a>概括：</h2><p>resnet解决信息损耗的方法是shortcut或者skip connections。如图所示<img src="/2022/08/25/resnet/2.png" alt>。为了解决这个问题。假设现有一个比较浅的网络（Shallow Net）已达到了饱和的准确率，这时在它后面再加上几个恒等映射层（Identity mapping，也即y=x，输出等于输入），这样就增加了网络的深度，并且起码误差不会增加，也即更深的网络不应该带来训练集上误差的上升。而这里提到的使用恒等映射直接将前一层输出传到后面的思想，便是著名深度残差网络ResNet的灵感来源。</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="/2022/08/25/resnet/1.png" alt><br><img src="/2022/08/25/resnet/4.png" alt><br>如图所示维resnetv1的网络结构。网络前几层使用3<em>3卷积之后接maxpooling提取显著特征同时增大感受野。网络分成4个stage并通过skip connections直接将输入信息绕道传到输出，保护信息的完整性，整个网络只需要学习输入、输出差别的那一部分，简化学习目标和难度。<br><img src="/2022/08/25/resnet/3.png" alt><br>resnet有两种残差连接方式，一种是以两个3</em>3的卷积网络串接在一起作为一个残差模块，另外一种是1<em>1、3</em>3、1*1的3个卷积网络串接在一起作为一个残差模块。他们如图所示。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>这种残差跳跃式的结构，打破了传统的神经网络n-1层的输出只能给n层作为输入的惯例，使某一层的输出可以直接跨过几层作为后面某一层的输入，其意义在于为叠加多层网络而使得整个学习模型的错误率不降反升的难题提供了新的方向。<br>至此，神经网络的层数可以超越之前的约束，达到几十层、上百层甚至千层，为高级语义特征提取和分类提供了可行性。<br><img src="/2022/08/25/resnet/5.png" alt>完整的resnet的网络结构非常壮观。</p><h2 id="不同通道连接"><a href="#不同通道连接" class="headerlink" title="不同通道连接"></a>不同通道连接</h2><p>从图可以看出，怎么有一些“shortcut connections（捷径连接）”是实线，有一些是虚线，有什么区别呢？<br><img src="/2022/08/25/resnet/6.png" alt><br>因为经过“shortcut connections（捷径连接）”后，H(x)=F(x)+x，如果F(x)和x的通道相同，则可直接相加，那么通道不同怎么相加呢。对通道数不同的情况，只需要通过卷积操作改变通道数即可。上图中的实线、虚线就是为了区分这两种情况的：</p><p>实线的Connection部分，表示通道相同，如上图的第一个粉色矩形和第三个粉色矩形，都是3x3x64的特征图，由于通道相同，所以采用计算方式为H(x)=F(x)+x<br>虚线的的Connection部分，表示通道不同，如上图的第一个绿色矩形和第三个绿色矩形，分别是3x3x64和3x3x128的特征图，通道不同，采用的计算方式为H(x)=F(x)+Wx，其中W是卷积操作，用来调整x维度的。</p><h2 id="resnet-v2"><a href="#resnet-v2" class="headerlink" title="resnet v2"></a>resnet v2</h2><p>ResNet V2 和 ResNet V1 的主要区别在于，作者通过研究 ResNet 残差学习单元的传播公式，发现前馈和反馈信号可以直接传输，因此“shortcut connection”（捷径连接）的非线性激活函数（如ReLU）替换为 Identity Mappings。同时，ResNet V2 在每一层中都使用了 Batch Normalization。这样处理后，新的残差学习单元比以前更容易训练且泛化性更强。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SEnet</title>
      <link href="/2022/08/22/SEnet/"/>
      <url>/2022/08/22/SEnet/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-22 20:02:38</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>卷积神经网络的核心构件是卷积算子，它可以通过融合每一层局部接受域内的空间信息和信道信息来构建信息特征。<br>先前的研究主要是加强网络对空间尺度内的表示能力。而SEnet更关注通道间的关系。设计了一种SE块<br>这种SE块既可以堆叠成一个网络用来完成相关任务，也可以在现有模型中加入这种通道注意力的机制用来提高原始模型的表示能力</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>首先输入神经网络的图或是特征图的尺度如下<img src="/2022/08/22/SEnet/3.png" alt><br>先前的神经网络的工作都是在空间（HW）尺度内改进网络的效果。如何在空间尺度内改进网络效果呢？<br>首先回顾一下卷积<br>放一张卷积与全连接的对比图<br><img src="/2022/08/22/SEnet/4.png" alt><br><img src="/2022/08/22/SEnet/5.png" alt><br>对比发现，卷积相较于全连接。首先就是可以直观的表示特征。与卷积核相似度高的区域得分会更高。<br>卷积的参数更少，这可以增加网络的鲁棒性。<br>但是卷积相较于全连接的缺点也很明显。卷积的提取出的特征并不是全局的特征，受卷积的感受野的限制<br>那么如何在空间尺度上提升网络的性能呢？<br>很显而易见的是增加网络的感受野，使得提取出的特征尽可能是全局特征。<br>增加感受野的方法如下：下采样（池化），增大卷积核，加深网络<br>VGG使用减小卷积核的方法在增大感受野的同时减少参数<br><img src="/2022/08/22/SEnet/6.png" alt><br>为了解决在加深网络的同时带来的问题，resnet引入了残差模块，highwaynet与之类似。<br><img src="/2022/08/22/SEnet/7.png" alt></p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>之前的研究表明加深网络的深度可以增强网络的表示能力。为了加深网络出现了一些方法。比如vgg使用小卷积核增加网络深度，使用Batch Normalization (BN)来加快网络的学习速度。<br>ResNeT加入残差块，HighNet使用门控机制来调节一些层的信息会走捷径（一些信息不经过卷积层直接来到下一层）。分组卷积增加卷积次数增加卷积深度。</p><h2 id="注意力门控机制"><a href="#注意力门控机制" class="headerlink" title="注意力门控机制"></a>注意力门控机制</h2><p>注意力机制可以被解释为将一些可计算资源不按照平均分配而是将最多的计算资源分配到信息最丰富的部分中的一种手段。文中的SE块就是一种注意力门控机制</p><h2 id="SQUEEZE-AND-EXCITATION-BLOCKS"><a href="#SQUEEZE-AND-EXCITATION-BLOCKS" class="headerlink" title="SQUEEZE-AND-EXCITATION BLOCKS"></a>SQUEEZE-AND-EXCITATION BLOCKS</h2><p><img src="/2022/08/22/SEnet/1.png" alt><br>如图所示，SQUEEZE-AND-EXCITATION BLOCKS是在卷积操作之后，先压缩成一个C维的向量，再对这个向量进行激活得到一个权重向量。并将这个这个权重作为对输出结果C的权重。得到校准后的结果可以直接作为下一层的输入。</p><h3 id="SQUEEZE"><a href="#SQUEEZE" class="headerlink" title="SQUEEZE"></a>SQUEEZE</h3><p>Squeeze部分就是对每个通道进行全局聚合。SEnet使用全局平均池化，也可以使用其他更复杂的聚合方式，但是使用这种简单的聚合方式已经可以提升网络的性能。</p><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>SE块中的激活函数需要满足两个条件：<br>1.这个激活需要是非线性的，2，这个激活应该是非互斥的（即应该允许出现多个通道可以被高响应的而不是只有一个通道被高响应）</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><img src="/2022/08/22/SEnet/8.png" alt><br><img src="/2022/08/22/SEnet/9.png" alt><br>se块在VGG和RESNET中的应用。</p><h2 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2><h3 id="减速比"><a href="#减速比" class="headerlink" title="减速比"></a>减速比</h3><p><img src="/2022/08/22/SEnet/10.png" alt><br>比较效果时观察准确率的同时还应注重参数量和计算速度。综合两个结果</p><h3 id="聚合方式"><a href="#聚合方式" class="headerlink" title="聚合方式"></a>聚合方式</h3><p><img src="/2022/08/22/SEnet/11.png" alt><br>最大池化可以提取特征纹理， 最大池化提取边缘等“最重要”的特征</p><p>平均池化可以保留背景信息，平均池化提取的特征更加smoothly</p><p>ResNet在输入全连接层之前利用Kernel Size=7的AvgPooling来降维。反之为了减少无用信息的影响时用maxpool。网络浅层用maxpooling来进行降维。</p><p>但是全局平均池化的窗口太大了尤其浅层使用GMP其中一个像素点对应的感受野非常小。不能捕捉到全局信息。</p><p>CAM提到，在分类问题中gmp和gap并看不出孰优孰劣。但是要让卷积神经网络的对其分类结果给出一个合理解释，必须要充分利用好最后一个卷积层。GAP相较于GMP来说更充分的利用了空间信息</p><p>文章中处于对全局信息的考虑使用了GAP</p><h3 id="使用位置"><a href="#使用位置" class="headerlink" title="使用位置"></a>使用位置</h3><p><img src="/2022/08/22/SEnet/12.png" alt><br>resnet的四个阶段中使用，效果可以叠加。因为卷积神经网络深层浅层具有不同的效果。浅层神经网络提取类无关的特征。深层卷积网络作用是提取抽象的类相关的特征。因此四个阶段中的SE模块也有不同的作用</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>为什么Sigmoid效果最好，原文中提到：需要的激活函数应具备两个性质：<br>1.需要非线性<br>2.需要同时确保多个通道同时具有较高的权重，而不是只有一个通道获得高权重。<br>对比两个激活函数sigmoid函数将值限定在0-1之间，不会出现特别大的值分走过多的权重。<br><img src="/2022/08/22/SEnet/13.png" alt><br><img src="/2022/08/22/SEnet/14.png" alt><br><img src="/2022/08/22/SEnet/15.png" alt></p><h2 id="SE块的插入位置"><a href="#SE块的插入位置" class="headerlink" title="SE块的插入位置"></a>SE块的插入位置</h2><p><img src="/2022/08/22/SEnet/16.png" alt><br><img src="/2022/08/22/SEnet/17.png" alt><br>由结果看出，SE块需要插入在分支聚合前</p><h2 id="SE-3-3"><a href="#SE-3-3" class="headerlink" title="SE_3*3"></a>SE_3*3</h2><p><img src="/2022/08/22/SEnet/18.png" alt><br><img src="/2022/08/22/SEnet/19.png" alt><br>目的减少参数，将SE块放在中间通道少的地方，准确率略微下降，但是参数量显著减少。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VGG</title>
      <link href="/2022/08/20/VGG/"/>
      <url>/2022/08/20/VGG/</url>
      
        <content type="html"><![CDATA[<p>date: 2022-08-20 16:57:17</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h2 id="VGG网络动机"><a href="#VGG网络动机" class="headerlink" title="VGG网络动机"></a>VGG网络动机</h2><p>通过使用小卷积核代替大卷积核的方法，不改变感受野的同时减小网络参数。具体来说，vgg中使用三个3<em>3大小的卷积核代替7<strong>7的卷积核，使用两个3</strong>3的卷积核代替5*</em>5的卷积核。<br>这样做感受野不变的同时，增加了网络的深度，同时每层小卷积核后面都有RELU激活函数，（增加了激活层的个数）使网络引入更多非线性层。</p><h2 id="VGG的优缺点"><a href="#VGG的优缺点" class="headerlink" title="VGG的优缺点"></a>VGG的优缺点</h2><h3 id="VGG的优点"><a href="#VGG的优点" class="headerlink" title="VGG的优点"></a>VGG的优点</h3><p>VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（3x3）和最大池化尺寸（2x2）。<br>几个小滤波器（3x3）卷积层的组合比一个大滤波器（5x5或7x7）卷积层好：<br>验证了通过不断加深网络结构可以提升性能。</p><h3 id="VGG的缺点"><a href="#VGG的缺点" class="headerlink" title="VGG的缺点"></a>VGG的缺点</h3><p>VGG耗费更多计算资源，并且使用了更多的参数（这里不是3x3卷积的锅），导致更多的内存占用（140M）。其中绝大多数的参数都是来自于第一个全连接层。而且据其他人的实验可得<br>去掉这些全连接层并不会使网络效果变差。<br><img src="/2022/08/20/VGG/a.jpg" alt></p><h2 id="rule函数"><a href="#rule函数" class="headerlink" title="rule函数"></a>rule函数</h2><p>relu函数相较于sigmoid函数，梯度只有0，1.缓解了网络较深时梯度消失的问题。同时0代表网络节点未被激活使得网络具有一定的稀疏性。也可以抑制过拟合现象。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GoogLeNet</title>
      <link href="/2022/08/20/GoogLeNet/"/>
      <url>/2022/08/20/GoogLeNet/</url>
      
        <content type="html"><![CDATA[<hr><p>date: 2022-08-20 16:33:46</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h2 id="网络动机"><a href="#网络动机" class="headerlink" title="网络动机"></a>网络动机</h2><p>  提高网络性能最直接的方法就是增加网络尺寸。但是扩大网络会带来一些影响：<br>1.扩大神经网络会使得网络容易过拟合<br>2.神经网络较多参数会消耗较多的计算资源。文中提出了以下解决方案：<br>1。将全连接以及卷积层变为稀疏连接，2。同时使用了dropout的方法共同减少网络参数。<br>3.使用Max Pool和Average Pool。<br>4.使用Network in Network方法，增加网络的表现能力，这种方法可以看做是一个额外的1*1卷积层再加上一个ReLU层。NIN最重要的是降维，解决了计算瓶颈，从而解决网络尺寸受限的问题。这样就可以增加网络的深度和宽度了，而且不会有很大的性能损失。<br>5.当前最好的对象检测方法是R-CNN。R-CNN将检测问题分解为两个子问题：首先利用低级特征（颜色和超像素一致性）在分类不可知时寻找潜在目标，然后使用CNN分类器识别潜在目标所属类别。GoogLeNet在这两个阶段都进行了增强效果。</p><h2 id="GoogLeNet架构细节"><a href="#GoogLeNet架构细节" class="headerlink" title="GoogLeNet架构细节"></a>GoogLeNet架构细节</h2><p><img src="/2022/08/20/GoogLeNet/a.png" alt><br><img src="/2022/08/20/GoogLeNet/b.png" alt><br>图(a)是传统的多通道卷积操作，图(b)是GoogLeNet中使用的Inception模块，两者的区别在于：</p><p>Inception使用了多个不同尺寸的卷积核，还添加了池化，然后将卷积和池化结果串联在一起。<br>卷积之前有1×1的卷积操作，池化之后也有1×1的卷积操作。<br>Inception模块中的多尺寸卷积核的卷积卷积过程和普通卷积过程不同。<br>第一点不同的原因是：Inception的主要思想就是如何找出最优的局部稀疏结构并将其覆盖为近似的稠密组件，这里就是将不同的局部结构组合到了一起。<br>第二点不同的原因是：原始的卷积是广义线性模型GLM(generalized linear model)，GLM的抽象等级较低，无法很好的表达非线性特征，这种1×1的卷积操作将高相关性的节点聚集在一起。什么是高相关性节点呢？两张特征图中相同位置的节点就是相关性高的节点。假设当前层的输入大小是28×28×256，卷积核大小为1×1×256，卷积得到的输出大小为28×28×1。可以看出这种操作一方面将原来的线性模型变成了非线性模型，将高相关性节点组合到了一起，具有更强的表达能力，另一方面减少了参数个数</p><h2 id="辅助分类器"><a href="#辅助分类器" class="headerlink" title="辅助分类器"></a>辅助分类器</h2><p>神经网络的中间层也具有很强的识别能力，为了利用中间层抽象的特征，在某些中间层中添加含有多层的分类器。<br><img src="/2022/08/20/GoogLeNet/c.png" alt></p><h2 id="GoogLeNet网络架构"><a href="#GoogLeNet网络架构" class="headerlink" title="GoogLeNet网络架构"></a>GoogLeNet网络架构</h2><p><img src="/2022/08/20/GoogLeNet/d.png" alt><br>GoogLeNet神经网络中，使用了前两节提到的Inception模块和辅助分类器，而且由于全连接网络参数多，计算量大，容易过拟合，所以GoogLeNet没有采用AlexNet（2012年ImageNet冠军队使用的网络结构，前五层是卷积层，后三层是全连接层）中的全连接结构，直接在Inception模块之后使用Average Pool和Dropout方法，不仅起到降维作用，还在一定程度上防止过拟合。<br>在Dropout层之前添加了一个7×7的Average Pool，一方面是降维，另一方面也是对低层特征的组合。我们希望网络在高层可以抽象出图像全局的特征，那么应该在网络的高层增加卷积核的大小或者增加池化区域的大小，GoogLeNet将这种操作放到了最后的池化过程，前面的Inception模块中卷积核大小都是固定的，而且比较小，主要是为了卷积时的计算方便。<br>第二幅图中蓝色部分是卷积块，每个卷积块后都会跟一个ReLU（受限线性单元）层作为激活函数（包括Inception内部的卷积块）</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>训练7个GoogLeNet模型，其中包含一个加宽版本，其余6个模型初始化和超参数都一样，只是采样方法和样本顺序不同<br>采用模型和数据并行技术，用几个高端GPU训练一周可得到收敛(估算)<br>多个模型的训练是不同步的，超参数的变化也是不一样的，比如dropout和学习率<br>有些模型主要训练小尺寸样本，有些模型训练大尺寸样本<br>采样时，样本尺寸缩放从8%到100%，宽高比随机选取3/4或4/3（多尺度）<br>将图像作光度扭曲，也就是随机更改图像的对比度，亮度和颜色。这样可以增加网络对这些属性的不变性<br>使用随机插值方法重置图像尺寸（因为网络输入层的大小是固定的），<br>使用到的随机插值方法：双线性插值，区域插值，最近邻插值，三次方插值，这些插值方法等概率的被选择使用。图像放大时，像素也相应地增加 ，增加的过程就是“插值”程序自动选择信息较好的像素作为增加的像素，而并非只使用临近的像素，所以在放大图像时，图像看上去会比较平滑、干净<br>改变超参数（反向传播若干次之后改变超参数，或者误差达到某阈值时改变超参数）</p><h2 id="测试样本处理"><a href="#测试样本处理" class="headerlink" title="测试样本处理"></a>测试样本处理</h2><p>对于一个测试样本，将图像的短边缩放成4种尺寸，分别为256，288，320，352。<br>从每种尺寸的图像的左边，中间，右边（或者上面，中间，下面）分别截取一个方形区域。<br>从每个方形区域的4个拐角和中心分别截取一个224×224区域，再将方形区域缩小到224×224，这样每个方形区域能得到6张大小为224×224的图像，加上它们的镜像版本（将图像水平翻转），一共得到4×3×6×2=144张图像。</p><h1 id><a href="#" class="headerlink" title="#"></a>#</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/19/hello-world/"/>
      <url>/2022/08/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
